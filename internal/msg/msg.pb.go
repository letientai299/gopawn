// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: messages.proto

/*
	Package messages is a generated protocol buffer package.

	It is generated from these files:
		messages.proto

	It has these top-level messages:
		Envelope
		Location
		SourceReference
		Media
		Source
		GherkinDocument
		Attachment
		Pickle
		PickleStepArgument
		PickleAccepted
		PickleRejected
		TestRunStarted
		TestCasePreparedStep
		TestCasePrepared
		TestCaseStarted
		TestCaseFinished
		TestStepStarted
		TestStepFinished
		TestHookStarted
		TestHookFinished
		TestResult
		TestRunFinished
		CommandStart
		SourcesConfig
		SourcesFilterConfig
		UriToLinesMapping
		SourcesOrder
		RuntimeConfig
		SupportCodeConfig
		TestCaseHookDefinitionConfig
		StepDefinitionConfig
		StepDefinitionPattern
		ParameterTypeConfig
		CommandActionComplete
		CommandRunBeforeTestRunHooks
		CommandRunAfterTestRunHooks
		CommandInitializeTestCase
		CommandRunBeforeTestCaseHook
		CommandRunAfterTestCaseHook
		CommandRunTestStep
		PatternMatch
		CommandGenerateSnippet
		GeneratedExpression
*/
package msg

import (
	"fmt"
	"io"
	"math"

	"github.com/gogo/protobuf/proto"
	google_protobuf "github.com/gogo/protobuf/types"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type SourcesOrderType int32

const (
	SourcesOrderType_ORDER_OF_DEFINITION SourcesOrderType = 0
	SourcesOrderType_RANDOM              SourcesOrderType = 1
)

var SourcesOrderType_name = map[int32]string{
	0: "ORDER_OF_DEFINITION",
	1: "RANDOM",
}
var SourcesOrderType_value = map[string]int32{
	"ORDER_OF_DEFINITION": 0,
	"RANDOM":              1,
}

func (x SourcesOrderType) String() string {
	return proto.EnumName(SourcesOrderType_name, int32(x))
}
func (SourcesOrderType) EnumDescriptor() ([]byte, []int) { return fileDescriptorMessages, []int{0} }

type StepDefinitionPatternType int32

const (
	StepDefinitionPatternType_CUCUMBER_EXPRESSION StepDefinitionPatternType = 0
	StepDefinitionPatternType_REGULAR_EXPRESSION  StepDefinitionPatternType = 1
)

var StepDefinitionPatternType_name = map[int32]string{
	0: "CUCUMBER_EXPRESSION",
	1: "REGULAR_EXPRESSION",
}
var StepDefinitionPatternType_value = map[string]int32{
	"CUCUMBER_EXPRESSION": 0,
	"REGULAR_EXPRESSION":  1,
}

func (x StepDefinitionPatternType) String() string {
	return proto.EnumName(StepDefinitionPatternType_name, int32(x))
}
func (StepDefinitionPatternType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{1}
}

type Media_Encoding int32

const (
	// Base64 encoded binary data
	Media_BASE64 Media_Encoding = 0
	// UTF8 encoded string
	Media_UTF8 Media_Encoding = 1
)

var Media_Encoding_name = map[int32]string{
	0: "BASE64",
	1: "UTF8",
}
var Media_Encoding_value = map[string]int32{
	"BASE64": 0,
	"UTF8":   1,
}

func (x Media_Encoding) String() string {
	return proto.EnumName(Media_Encoding_name, int32(x))
}
func (Media_Encoding) EnumDescriptor() ([]byte, []int) { return fileDescriptorMessages, []int{3, 0} }

type TestResult_Status int32

const (
	TestResult_AMBIGUOUS TestResult_Status = 0
	TestResult_FAILED    TestResult_Status = 1
	TestResult_PASSED    TestResult_Status = 2
	TestResult_PENDING   TestResult_Status = 3
	TestResult_SKIPPED   TestResult_Status = 4
	TestResult_UNDEFINED TestResult_Status = 5
)

var TestResult_Status_name = map[int32]string{
	0: "AMBIGUOUS",
	1: "FAILED",
	2: "PASSED",
	3: "PENDING",
	4: "SKIPPED",
	5: "UNDEFINED",
}
var TestResult_Status_value = map[string]int32{
	"AMBIGUOUS": 0,
	"FAILED":    1,
	"PASSED":    2,
	"PENDING":   3,
	"SKIPPED":   4,
	"UNDEFINED": 5,
}

func (x TestResult_Status) String() string {
	return proto.EnumName(TestResult_Status_name, int32(x))
}
func (TestResult_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptorMessages, []int{20, 0} }

// *
// All the messages that are passed between different components/processes are Envelope
// messages.
type Envelope struct {
	// Types that are valid to be assigned to Message:
	//	*Envelope_Source
	//	*Envelope_GherkinDocument
	//	*Envelope_Pickle
	//	*Envelope_Attachment
	//	*Envelope_TestCaseStarted
	//	*Envelope_TestStepStarted
	//	*Envelope_TestStepFinished
	//	*Envelope_TestCaseFinished
	//	*Envelope_TestHookStarted
	//	*Envelope_TestHookFinished
	//	*Envelope_PickleAccepted
	//	*Envelope_PickleRejected
	//	*Envelope_TestCasePrepared
	//	*Envelope_TestRunStarted
	//	*Envelope_TestRunFinished
	//	*Envelope_CommandStart
	//	*Envelope_CommandActionComplete
	//	*Envelope_CommandRunBeforeTestRunHooks
	//	*Envelope_CommandInitializeTestCase
	//	*Envelope_CommandRunBeforeTestCaseHook
	//	*Envelope_CommandRunTestStep
	//	*Envelope_CommandRunAfterTestCaseHook
	//	*Envelope_CommandRunAfterTestRunHooks
	//	*Envelope_CommandGenerateSnippet
	//	*Envelope_CommandError
	Message isEnvelope_Message `protobuf_oneof:"message"`
}

func (m *Envelope) Reset()                    { *m = Envelope{} }
func (m *Envelope) String() string            { return proto.CompactTextString(m) }
func (*Envelope) ProtoMessage()               {}
func (*Envelope) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{0} }

type isEnvelope_Message interface {
	isEnvelope_Message()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Envelope_Source struct {
	Source *Source `protobuf:"bytes,1,opt,name=source,oneof"`
}
type Envelope_GherkinDocument struct {
	GherkinDocument *GherkinDocument `protobuf:"bytes,2,opt,name=gherkinDocument,oneof"`
}
type Envelope_Pickle struct {
	Pickle *Pickle `protobuf:"bytes,3,opt,name=pickle,oneof"`
}
type Envelope_Attachment struct {
	Attachment *Attachment `protobuf:"bytes,4,opt,name=attachment,oneof"`
}
type Envelope_TestCaseStarted struct {
	TestCaseStarted *TestCaseStarted `protobuf:"bytes,5,opt,name=testCaseStarted,oneof"`
}
type Envelope_TestStepStarted struct {
	TestStepStarted *TestStepStarted `protobuf:"bytes,6,opt,name=testStepStarted,oneof"`
}
type Envelope_TestStepFinished struct {
	TestStepFinished *TestStepFinished `protobuf:"bytes,7,opt,name=testStepFinished,oneof"`
}
type Envelope_TestCaseFinished struct {
	TestCaseFinished *TestCaseFinished `protobuf:"bytes,8,opt,name=testCaseFinished,oneof"`
}
type Envelope_TestHookStarted struct {
	TestHookStarted *TestHookStarted `protobuf:"bytes,9,opt,name=testHookStarted,oneof"`
}
type Envelope_TestHookFinished struct {
	TestHookFinished *TestHookFinished `protobuf:"bytes,10,opt,name=testHookFinished,oneof"`
}
type Envelope_PickleAccepted struct {
	PickleAccepted *PickleAccepted `protobuf:"bytes,11,opt,name=pickleAccepted,oneof"`
}
type Envelope_PickleRejected struct {
	PickleRejected *PickleRejected `protobuf:"bytes,12,opt,name=pickleRejected,oneof"`
}
type Envelope_TestCasePrepared struct {
	TestCasePrepared *TestCasePrepared `protobuf:"bytes,13,opt,name=testCasePrepared,oneof"`
}
type Envelope_TestRunStarted struct {
	TestRunStarted *TestRunStarted `protobuf:"bytes,14,opt,name=testRunStarted,oneof"`
}
type Envelope_TestRunFinished struct {
	TestRunFinished *TestRunFinished `protobuf:"bytes,15,opt,name=testRunFinished,oneof"`
}
type Envelope_CommandStart struct {
	CommandStart *CommandStart `protobuf:"bytes,16,opt,name=commandStart,oneof"`
}
type Envelope_CommandActionComplete struct {
	CommandActionComplete *CommandActionComplete `protobuf:"bytes,17,opt,name=commandActionComplete,oneof"`
}
type Envelope_CommandRunBeforeTestRunHooks struct {
	CommandRunBeforeTestRunHooks *CommandRunBeforeTestRunHooks `protobuf:"bytes,18,opt,name=commandRunBeforeTestRunHooks,oneof"`
}
type Envelope_CommandInitializeTestCase struct {
	CommandInitializeTestCase *CommandInitializeTestCase `protobuf:"bytes,19,opt,name=commandInitializeTestCase,oneof"`
}
type Envelope_CommandRunBeforeTestCaseHook struct {
	CommandRunBeforeTestCaseHook *CommandRunBeforeTestCaseHook `protobuf:"bytes,20,opt,name=commandRunBeforeTestCaseHook,oneof"`
}
type Envelope_CommandRunTestStep struct {
	CommandRunTestStep *CommandRunTestStep `protobuf:"bytes,21,opt,name=commandRunTestStep,oneof"`
}
type Envelope_CommandRunAfterTestCaseHook struct {
	CommandRunAfterTestCaseHook *CommandRunAfterTestCaseHook `protobuf:"bytes,22,opt,name=commandRunAfterTestCaseHook,oneof"`
}
type Envelope_CommandRunAfterTestRunHooks struct {
	CommandRunAfterTestRunHooks *CommandRunAfterTestRunHooks `protobuf:"bytes,23,opt,name=commandRunAfterTestRunHooks,oneof"`
}
type Envelope_CommandGenerateSnippet struct {
	CommandGenerateSnippet *CommandGenerateSnippet `protobuf:"bytes,24,opt,name=commandGenerateSnippet,oneof"`
}
type Envelope_CommandError struct {
	CommandError string `protobuf:"bytes,25,opt,name=commandError,proto3,oneof"`
}

func (*Envelope_Source) isEnvelope_Message()                       {}
func (*Envelope_GherkinDocument) isEnvelope_Message()              {}
func (*Envelope_Pickle) isEnvelope_Message()                       {}
func (*Envelope_Attachment) isEnvelope_Message()                   {}
func (*Envelope_TestCaseStarted) isEnvelope_Message()              {}
func (*Envelope_TestStepStarted) isEnvelope_Message()              {}
func (*Envelope_TestStepFinished) isEnvelope_Message()             {}
func (*Envelope_TestCaseFinished) isEnvelope_Message()             {}
func (*Envelope_TestHookStarted) isEnvelope_Message()              {}
func (*Envelope_TestHookFinished) isEnvelope_Message()             {}
func (*Envelope_PickleAccepted) isEnvelope_Message()               {}
func (*Envelope_PickleRejected) isEnvelope_Message()               {}
func (*Envelope_TestCasePrepared) isEnvelope_Message()             {}
func (*Envelope_TestRunStarted) isEnvelope_Message()               {}
func (*Envelope_TestRunFinished) isEnvelope_Message()              {}
func (*Envelope_CommandStart) isEnvelope_Message()                 {}
func (*Envelope_CommandActionComplete) isEnvelope_Message()        {}
func (*Envelope_CommandRunBeforeTestRunHooks) isEnvelope_Message() {}
func (*Envelope_CommandInitializeTestCase) isEnvelope_Message()    {}
func (*Envelope_CommandRunBeforeTestCaseHook) isEnvelope_Message() {}
func (*Envelope_CommandRunTestStep) isEnvelope_Message()           {}
func (*Envelope_CommandRunAfterTestCaseHook) isEnvelope_Message()  {}
func (*Envelope_CommandRunAfterTestRunHooks) isEnvelope_Message()  {}
func (*Envelope_CommandGenerateSnippet) isEnvelope_Message()       {}
func (*Envelope_CommandError) isEnvelope_Message()                 {}

func (m *Envelope) GetMessage() isEnvelope_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Envelope) GetSource() *Source {
	if x, ok := m.GetMessage().(*Envelope_Source); ok {
		return x.Source
	}
	return nil
}

func (m *Envelope) GetGherkinDocument() *GherkinDocument {
	if x, ok := m.GetMessage().(*Envelope_GherkinDocument); ok {
		return x.GherkinDocument
	}
	return nil
}

func (m *Envelope) GetPickle() *Pickle {
	if x, ok := m.GetMessage().(*Envelope_Pickle); ok {
		return x.Pickle
	}
	return nil
}

func (m *Envelope) GetAttachment() *Attachment {
	if x, ok := m.GetMessage().(*Envelope_Attachment); ok {
		return x.Attachment
	}
	return nil
}

func (m *Envelope) GetTestCaseStarted() *TestCaseStarted {
	if x, ok := m.GetMessage().(*Envelope_TestCaseStarted); ok {
		return x.TestCaseStarted
	}
	return nil
}

func (m *Envelope) GetTestStepStarted() *TestStepStarted {
	if x, ok := m.GetMessage().(*Envelope_TestStepStarted); ok {
		return x.TestStepStarted
	}
	return nil
}

func (m *Envelope) GetTestStepFinished() *TestStepFinished {
	if x, ok := m.GetMessage().(*Envelope_TestStepFinished); ok {
		return x.TestStepFinished
	}
	return nil
}

func (m *Envelope) GetTestCaseFinished() *TestCaseFinished {
	if x, ok := m.GetMessage().(*Envelope_TestCaseFinished); ok {
		return x.TestCaseFinished
	}
	return nil
}

func (m *Envelope) GetTestHookStarted() *TestHookStarted {
	if x, ok := m.GetMessage().(*Envelope_TestHookStarted); ok {
		return x.TestHookStarted
	}
	return nil
}

func (m *Envelope) GetTestHookFinished() *TestHookFinished {
	if x, ok := m.GetMessage().(*Envelope_TestHookFinished); ok {
		return x.TestHookFinished
	}
	return nil
}

func (m *Envelope) GetPickleAccepted() *PickleAccepted {
	if x, ok := m.GetMessage().(*Envelope_PickleAccepted); ok {
		return x.PickleAccepted
	}
	return nil
}

func (m *Envelope) GetPickleRejected() *PickleRejected {
	if x, ok := m.GetMessage().(*Envelope_PickleRejected); ok {
		return x.PickleRejected
	}
	return nil
}

func (m *Envelope) GetTestCasePrepared() *TestCasePrepared {
	if x, ok := m.GetMessage().(*Envelope_TestCasePrepared); ok {
		return x.TestCasePrepared
	}
	return nil
}

func (m *Envelope) GetTestRunStarted() *TestRunStarted {
	if x, ok := m.GetMessage().(*Envelope_TestRunStarted); ok {
		return x.TestRunStarted
	}
	return nil
}

func (m *Envelope) GetTestRunFinished() *TestRunFinished {
	if x, ok := m.GetMessage().(*Envelope_TestRunFinished); ok {
		return x.TestRunFinished
	}
	return nil
}

func (m *Envelope) GetCommandStart() *CommandStart {
	if x, ok := m.GetMessage().(*Envelope_CommandStart); ok {
		return x.CommandStart
	}
	return nil
}

func (m *Envelope) GetCommandActionComplete() *CommandActionComplete {
	if x, ok := m.GetMessage().(*Envelope_CommandActionComplete); ok {
		return x.CommandActionComplete
	}
	return nil
}

func (m *Envelope) GetCommandRunBeforeTestRunHooks() *CommandRunBeforeTestRunHooks {
	if x, ok := m.GetMessage().(*Envelope_CommandRunBeforeTestRunHooks); ok {
		return x.CommandRunBeforeTestRunHooks
	}
	return nil
}

func (m *Envelope) GetCommandInitializeTestCase() *CommandInitializeTestCase {
	if x, ok := m.GetMessage().(*Envelope_CommandInitializeTestCase); ok {
		return x.CommandInitializeTestCase
	}
	return nil
}

func (m *Envelope) GetCommandRunBeforeTestCaseHook() *CommandRunBeforeTestCaseHook {
	if x, ok := m.GetMessage().(*Envelope_CommandRunBeforeTestCaseHook); ok {
		return x.CommandRunBeforeTestCaseHook
	}
	return nil
}

func (m *Envelope) GetCommandRunTestStep() *CommandRunTestStep {
	if x, ok := m.GetMessage().(*Envelope_CommandRunTestStep); ok {
		return x.CommandRunTestStep
	}
	return nil
}

func (m *Envelope) GetCommandRunAfterTestCaseHook() *CommandRunAfterTestCaseHook {
	if x, ok := m.GetMessage().(*Envelope_CommandRunAfterTestCaseHook); ok {
		return x.CommandRunAfterTestCaseHook
	}
	return nil
}

func (m *Envelope) GetCommandRunAfterTestRunHooks() *CommandRunAfterTestRunHooks {
	if x, ok := m.GetMessage().(*Envelope_CommandRunAfterTestRunHooks); ok {
		return x.CommandRunAfterTestRunHooks
	}
	return nil
}

func (m *Envelope) GetCommandGenerateSnippet() *CommandGenerateSnippet {
	if x, ok := m.GetMessage().(*Envelope_CommandGenerateSnippet); ok {
		return x.CommandGenerateSnippet
	}
	return nil
}

func (m *Envelope) GetCommandError() string {
	if x, ok := m.GetMessage().(*Envelope_CommandError); ok {
		return x.CommandError
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Envelope) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Envelope_OneofMarshaler, _Envelope_OneofUnmarshaler, _Envelope_OneofSizer, []interface{}{
		(*Envelope_Source)(nil),
		(*Envelope_GherkinDocument)(nil),
		(*Envelope_Pickle)(nil),
		(*Envelope_Attachment)(nil),
		(*Envelope_TestCaseStarted)(nil),
		(*Envelope_TestStepStarted)(nil),
		(*Envelope_TestStepFinished)(nil),
		(*Envelope_TestCaseFinished)(nil),
		(*Envelope_TestHookStarted)(nil),
		(*Envelope_TestHookFinished)(nil),
		(*Envelope_PickleAccepted)(nil),
		(*Envelope_PickleRejected)(nil),
		(*Envelope_TestCasePrepared)(nil),
		(*Envelope_TestRunStarted)(nil),
		(*Envelope_TestRunFinished)(nil),
		(*Envelope_CommandStart)(nil),
		(*Envelope_CommandActionComplete)(nil),
		(*Envelope_CommandRunBeforeTestRunHooks)(nil),
		(*Envelope_CommandInitializeTestCase)(nil),
		(*Envelope_CommandRunBeforeTestCaseHook)(nil),
		(*Envelope_CommandRunTestStep)(nil),
		(*Envelope_CommandRunAfterTestCaseHook)(nil),
		(*Envelope_CommandRunAfterTestRunHooks)(nil),
		(*Envelope_CommandGenerateSnippet)(nil),
		(*Envelope_CommandError)(nil),
	}
}

func _Envelope_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Envelope)
	// message
	switch x := m.Message.(type) {
	case *Envelope_Source:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Source); err != nil {
			return err
		}
	case *Envelope_GherkinDocument:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GherkinDocument); err != nil {
			return err
		}
	case *Envelope_Pickle:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Pickle); err != nil {
			return err
		}
	case *Envelope_Attachment:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Attachment); err != nil {
			return err
		}
	case *Envelope_TestCaseStarted:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestCaseStarted); err != nil {
			return err
		}
	case *Envelope_TestStepStarted:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestStepStarted); err != nil {
			return err
		}
	case *Envelope_TestStepFinished:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestStepFinished); err != nil {
			return err
		}
	case *Envelope_TestCaseFinished:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestCaseFinished); err != nil {
			return err
		}
	case *Envelope_TestHookStarted:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestHookStarted); err != nil {
			return err
		}
	case *Envelope_TestHookFinished:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestHookFinished); err != nil {
			return err
		}
	case *Envelope_PickleAccepted:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PickleAccepted); err != nil {
			return err
		}
	case *Envelope_PickleRejected:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PickleRejected); err != nil {
			return err
		}
	case *Envelope_TestCasePrepared:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestCasePrepared); err != nil {
			return err
		}
	case *Envelope_TestRunStarted:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestRunStarted); err != nil {
			return err
		}
	case *Envelope_TestRunFinished:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestRunFinished); err != nil {
			return err
		}
	case *Envelope_CommandStart:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandStart); err != nil {
			return err
		}
	case *Envelope_CommandActionComplete:
		_ = b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandActionComplete); err != nil {
			return err
		}
	case *Envelope_CommandRunBeforeTestRunHooks:
		_ = b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandRunBeforeTestRunHooks); err != nil {
			return err
		}
	case *Envelope_CommandInitializeTestCase:
		_ = b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandInitializeTestCase); err != nil {
			return err
		}
	case *Envelope_CommandRunBeforeTestCaseHook:
		_ = b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandRunBeforeTestCaseHook); err != nil {
			return err
		}
	case *Envelope_CommandRunTestStep:
		_ = b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandRunTestStep); err != nil {
			return err
		}
	case *Envelope_CommandRunAfterTestCaseHook:
		_ = b.EncodeVarint(22<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandRunAfterTestCaseHook); err != nil {
			return err
		}
	case *Envelope_CommandRunAfterTestRunHooks:
		_ = b.EncodeVarint(23<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandRunAfterTestRunHooks); err != nil {
			return err
		}
	case *Envelope_CommandGenerateSnippet:
		_ = b.EncodeVarint(24<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandGenerateSnippet); err != nil {
			return err
		}
	case *Envelope_CommandError:
		_ = b.EncodeVarint(25<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.CommandError)
	case nil:
	default:
		return fmt.Errorf("Envelope.Message has unexpected type %T", x)
	}
	return nil
}

func _Envelope_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Envelope)
	switch tag {
	case 1: // message.source
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Source)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_Source{msg}
		return true, err
	case 2: // message.gherkinDocument
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GherkinDocument)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_GherkinDocument{msg}
		return true, err
	case 3: // message.pickle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Pickle)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_Pickle{msg}
		return true, err
	case 4: // message.attachment
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Attachment)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_Attachment{msg}
		return true, err
	case 5: // message.testCaseStarted
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestCaseStarted)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_TestCaseStarted{msg}
		return true, err
	case 6: // message.testStepStarted
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestStepStarted)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_TestStepStarted{msg}
		return true, err
	case 7: // message.testStepFinished
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestStepFinished)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_TestStepFinished{msg}
		return true, err
	case 8: // message.testCaseFinished
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestCaseFinished)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_TestCaseFinished{msg}
		return true, err
	case 9: // message.testHookStarted
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestHookStarted)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_TestHookStarted{msg}
		return true, err
	case 10: // message.testHookFinished
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestHookFinished)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_TestHookFinished{msg}
		return true, err
	case 11: // message.pickleAccepted
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PickleAccepted)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_PickleAccepted{msg}
		return true, err
	case 12: // message.pickleRejected
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PickleRejected)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_PickleRejected{msg}
		return true, err
	case 13: // message.testCasePrepared
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestCasePrepared)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_TestCasePrepared{msg}
		return true, err
	case 14: // message.testRunStarted
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestRunStarted)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_TestRunStarted{msg}
		return true, err
	case 15: // message.testRunFinished
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestRunFinished)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_TestRunFinished{msg}
		return true, err
	case 16: // message.commandStart
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandStart)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_CommandStart{msg}
		return true, err
	case 17: // message.commandActionComplete
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandActionComplete)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_CommandActionComplete{msg}
		return true, err
	case 18: // message.commandRunBeforeTestRunHooks
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandRunBeforeTestRunHooks)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_CommandRunBeforeTestRunHooks{msg}
		return true, err
	case 19: // message.commandInitializeTestCase
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandInitializeTestCase)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_CommandInitializeTestCase{msg}
		return true, err
	case 20: // message.commandRunBeforeTestCaseHook
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandRunBeforeTestCaseHook)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_CommandRunBeforeTestCaseHook{msg}
		return true, err
	case 21: // message.commandRunTestStep
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandRunTestStep)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_CommandRunTestStep{msg}
		return true, err
	case 22: // message.commandRunAfterTestCaseHook
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandRunAfterTestCaseHook)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_CommandRunAfterTestCaseHook{msg}
		return true, err
	case 23: // message.commandRunAfterTestRunHooks
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandRunAfterTestRunHooks)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_CommandRunAfterTestRunHooks{msg}
		return true, err
	case 24: // message.commandGenerateSnippet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandGenerateSnippet)
		err := b.DecodeMessage(msg)
		m.Message = &Envelope_CommandGenerateSnippet{msg}
		return true, err
	case 25: // message.commandError
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Message = &Envelope_CommandError{x}
		return true, err
	default:
		return false, nil
	}
}

func _Envelope_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Envelope)
	// message
	switch x := m.Message.(type) {
	case *Envelope_Source:
		s := proto.Size(x.Source)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_GherkinDocument:
		s := proto.Size(x.GherkinDocument)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_Pickle:
		s := proto.Size(x.Pickle)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_Attachment:
		s := proto.Size(x.Attachment)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_TestCaseStarted:
		s := proto.Size(x.TestCaseStarted)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_TestStepStarted:
		s := proto.Size(x.TestStepStarted)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_TestStepFinished:
		s := proto.Size(x.TestStepFinished)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_TestCaseFinished:
		s := proto.Size(x.TestCaseFinished)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_TestHookStarted:
		s := proto.Size(x.TestHookStarted)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_TestHookFinished:
		s := proto.Size(x.TestHookFinished)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_PickleAccepted:
		s := proto.Size(x.PickleAccepted)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_PickleRejected:
		s := proto.Size(x.PickleRejected)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_TestCasePrepared:
		s := proto.Size(x.TestCasePrepared)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_TestRunStarted:
		s := proto.Size(x.TestRunStarted)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_TestRunFinished:
		s := proto.Size(x.TestRunFinished)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_CommandStart:
		s := proto.Size(x.CommandStart)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_CommandActionComplete:
		s := proto.Size(x.CommandActionComplete)
		n += proto.SizeVarint(17<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_CommandRunBeforeTestRunHooks:
		s := proto.Size(x.CommandRunBeforeTestRunHooks)
		n += proto.SizeVarint(18<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_CommandInitializeTestCase:
		s := proto.Size(x.CommandInitializeTestCase)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_CommandRunBeforeTestCaseHook:
		s := proto.Size(x.CommandRunBeforeTestCaseHook)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_CommandRunTestStep:
		s := proto.Size(x.CommandRunTestStep)
		n += proto.SizeVarint(21<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_CommandRunAfterTestCaseHook:
		s := proto.Size(x.CommandRunAfterTestCaseHook)
		n += proto.SizeVarint(22<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_CommandRunAfterTestRunHooks:
		s := proto.Size(x.CommandRunAfterTestRunHooks)
		n += proto.SizeVarint(23<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_CommandGenerateSnippet:
		s := proto.Size(x.CommandGenerateSnippet)
		n += proto.SizeVarint(24<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Envelope_CommandError:
		n += proto.SizeVarint(25<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.CommandError)))
		n += len(x.CommandError)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// *
// Points to a line and a column in a text file
type Location struct {
	Line   uint32 `protobuf:"varint,1,opt,name=line,proto3" json:"line,omitempty"`
	Column uint32 `protobuf:"varint,2,opt,name=column,proto3" json:"column,omitempty"`
}

func (m *Location) Reset()                    { *m = Location{} }
func (m *Location) String() string            { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()               {}
func (*Location) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{1} }

func (m *Location) GetLine() uint32 {
	if m != nil {
		return m.Line
	}
	return 0
}

func (m *Location) GetColumn() uint32 {
	if m != nil {
		return m.Column
	}
	return 0
}

// *
// Points to a [Source](#io.cucumber.messages.Source) identified by `uri` and a
// [Location](#io.cucumber.messages.Location) within that file.
type SourceReference struct {
	Uri      string    `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	Location *Location `protobuf:"bytes,2,opt,name=location" json:"location,omitempty"`
}

func (m *SourceReference) Reset()                    { *m = SourceReference{} }
func (m *SourceReference) String() string            { return proto.CompactTextString(m) }
func (*SourceReference) ProtoMessage()               {}
func (*SourceReference) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{2} }

func (m *SourceReference) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *SourceReference) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

// *
// Meta information about encoded contents
type Media struct {
	// The encoding of the data
	Encoding Media_Encoding `protobuf:"varint,1,opt,name=encoding,proto3,enum=io.cucumber.messages.Media_Encoding" json:"encoding,omitempty"`
	// *
	// The content type of the data. This can be any valid
	// [IANA Media Type](https://www.iana.org/assignments/media-types/media-types.xhtml)
	// as well as Cucumber-specific media types such as `text/x.cucumber.gherkin+plain`
	// and `text/x.cucumber.stacktrace+plain`
	ContentType string `protobuf:"bytes,2,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
}

func (m *Media) Reset()                    { *m = Media{} }
func (m *Media) String() string            { return proto.CompactTextString(m) }
func (*Media) ProtoMessage()               {}
func (*Media) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{3} }

func (m *Media) GetEncoding() Media_Encoding {
	if m != nil {
		return m.Encoding
	}
	return Media_BASE64
}

func (m *Media) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

// *
// A source file, typically a Gherkin document
type Source struct {
	// *
	// The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
	// of the source, typically a file path relative to the root directory
	Uri string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	// The contents of the file
	Data string `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	// The media type of the file
	Media *Media `protobuf:"bytes,3,opt,name=media" json:"media,omitempty"`
}

func (m *Source) Reset()                    { *m = Source{} }
func (m *Source) String() string            { return proto.CompactTextString(m) }
func (*Source) ProtoMessage()               {}
func (*Source) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{4} }

func (m *Source) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *Source) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *Source) GetMedia() *Media {
	if m != nil {
		return m.Media
	}
	return nil
}

// *
// The [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) of a Gherkin document.
// Cucumber implementations should *not* depend on `GherkinDocument` or any of its
// children for execution - use [Pickle](#io.cucumber.messages.Pickle) instead.
//
// The only consumers of `GherkinDocument` should only be formatters that produce
// "rich" output, resembling the original Gherkin document.
type GherkinDocument struct {
	// *
	// The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
	// of the source, typically a file path relative to the root directory
	Uri     string                   `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	Feature *GherkinDocument_Feature `protobuf:"bytes,2,opt,name=feature" json:"feature,omitempty"`
	// All the comments in the Gherkin document
	Comments []*GherkinDocument_Comment `protobuf:"bytes,3,rep,name=comments" json:"comments,omitempty"`
}

func (m *GherkinDocument) Reset()                    { *m = GherkinDocument{} }
func (m *GherkinDocument) String() string            { return proto.CompactTextString(m) }
func (*GherkinDocument) ProtoMessage()               {}
func (*GherkinDocument) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{5} }

func (m *GherkinDocument) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *GherkinDocument) GetFeature() *GherkinDocument_Feature {
	if m != nil {
		return m.Feature
	}
	return nil
}

func (m *GherkinDocument) GetComments() []*GherkinDocument_Comment {
	if m != nil {
		return m.Comments
	}
	return nil
}

// *
// A comment in a Gherkin document
type GherkinDocument_Comment struct {
	// The location of the comment
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	// The text of the comment
	Text string `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
}

func (m *GherkinDocument_Comment) Reset()         { *m = GherkinDocument_Comment{} }
func (m *GherkinDocument_Comment) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Comment) ProtoMessage()    {}
func (*GherkinDocument_Comment) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{5, 0}
}

func (m *GherkinDocument_Comment) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Comment) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

// *
// The top level node in the AST
type GherkinDocument_Feature struct {
	// The location of the `Feature` keyword
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	// All the tags placed above the `Feature` keyword
	Tags []*GherkinDocument_Feature_Tag `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty"`
	// The [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) language code of the Gherkin document
	Language string `protobuf:"bytes,3,opt,name=language,proto3" json:"language,omitempty"`
	// The text of the `Feature` keyword (in the language specified by `language`)
	Keyword string `protobuf:"bytes,4,opt,name=keyword,proto3" json:"keyword,omitempty"`
	// The name of the feature (the text following the `keyword`)
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	// The line(s) underneath the line with the `keyword` that are used as description
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	// Zero or more children
	Children []*GherkinDocument_Feature_FeatureChild `protobuf:"bytes,7,rep,name=children" json:"children,omitempty"`
}

func (m *GherkinDocument_Feature) Reset()         { *m = GherkinDocument_Feature{} }
func (m *GherkinDocument_Feature) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature) ProtoMessage()    {}
func (*GherkinDocument_Feature) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{5, 1}
}

func (m *GherkinDocument_Feature) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature) GetTags() []*GherkinDocument_Feature_Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *GherkinDocument_Feature) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *GherkinDocument_Feature) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *GherkinDocument_Feature) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GherkinDocument_Feature) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GherkinDocument_Feature) GetChildren() []*GherkinDocument_Feature_FeatureChild {
	if m != nil {
		return m.Children
	}
	return nil
}

// *
// A tag
type GherkinDocument_Feature_Tag struct {
	// Location of the tag
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	// The name of the tag (including the leading `@`)
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GherkinDocument_Feature_Tag) Reset()         { *m = GherkinDocument_Feature_Tag{} }
func (m *GherkinDocument_Feature_Tag) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Tag) ProtoMessage()    {}
func (*GherkinDocument_Feature_Tag) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{5, 1, 0}
}

func (m *GherkinDocument_Feature_Tag) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Tag) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// *
// A child node of a `Feature` node
type GherkinDocument_Feature_FeatureChild struct {
	// Types that are valid to be assigned to Value:
	//	*GherkinDocument_Feature_FeatureChild_Rule_
	//	*GherkinDocument_Feature_FeatureChild_Background
	//	*GherkinDocument_Feature_FeatureChild_Scenario
	Value isGherkinDocument_Feature_FeatureChild_Value `protobuf_oneof:"value"`
}

func (m *GherkinDocument_Feature_FeatureChild) Reset()         { *m = GherkinDocument_Feature_FeatureChild{} }
func (m *GherkinDocument_Feature_FeatureChild) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_FeatureChild) ProtoMessage()    {}
func (*GherkinDocument_Feature_FeatureChild) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{5, 1, 1}
}

type isGherkinDocument_Feature_FeatureChild_Value interface {
	isGherkinDocument_Feature_FeatureChild_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type GherkinDocument_Feature_FeatureChild_Rule_ struct {
	Rule *GherkinDocument_Feature_FeatureChild_Rule `protobuf:"bytes,1,opt,name=rule,oneof"`
}
type GherkinDocument_Feature_FeatureChild_Background struct {
	Background *GherkinDocument_Feature_Background `protobuf:"bytes,2,opt,name=background,oneof"`
}
type GherkinDocument_Feature_FeatureChild_Scenario struct {
	Scenario *GherkinDocument_Feature_Scenario `protobuf:"bytes,3,opt,name=scenario,oneof"`
}

func (*GherkinDocument_Feature_FeatureChild_Rule_) isGherkinDocument_Feature_FeatureChild_Value() {}
func (*GherkinDocument_Feature_FeatureChild_Background) isGherkinDocument_Feature_FeatureChild_Value() {
}
func (*GherkinDocument_Feature_FeatureChild_Scenario) isGherkinDocument_Feature_FeatureChild_Value() {}

func (m *GherkinDocument_Feature_FeatureChild) GetValue() isGherkinDocument_Feature_FeatureChild_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *GherkinDocument_Feature_FeatureChild) GetRule() *GherkinDocument_Feature_FeatureChild_Rule {
	if x, ok := m.GetValue().(*GherkinDocument_Feature_FeatureChild_Rule_); ok {
		return x.Rule
	}
	return nil
}

func (m *GherkinDocument_Feature_FeatureChild) GetBackground() *GherkinDocument_Feature_Background {
	if x, ok := m.GetValue().(*GherkinDocument_Feature_FeatureChild_Background); ok {
		return x.Background
	}
	return nil
}

func (m *GherkinDocument_Feature_FeatureChild) GetScenario() *GherkinDocument_Feature_Scenario {
	if x, ok := m.GetValue().(*GherkinDocument_Feature_FeatureChild_Scenario); ok {
		return x.Scenario
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GherkinDocument_Feature_FeatureChild) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GherkinDocument_Feature_FeatureChild_OneofMarshaler, _GherkinDocument_Feature_FeatureChild_OneofUnmarshaler, _GherkinDocument_Feature_FeatureChild_OneofSizer, []interface{}{
		(*GherkinDocument_Feature_FeatureChild_Rule_)(nil),
		(*GherkinDocument_Feature_FeatureChild_Background)(nil),
		(*GherkinDocument_Feature_FeatureChild_Scenario)(nil),
	}
}

func _GherkinDocument_Feature_FeatureChild_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GherkinDocument_Feature_FeatureChild)
	// value
	switch x := m.Value.(type) {
	case *GherkinDocument_Feature_FeatureChild_Rule_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Rule); err != nil {
			return err
		}
	case *GherkinDocument_Feature_FeatureChild_Background:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Background); err != nil {
			return err
		}
	case *GherkinDocument_Feature_FeatureChild_Scenario:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Scenario); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GherkinDocument_Feature_FeatureChild.Value has unexpected type %T", x)
	}
	return nil
}

func _GherkinDocument_Feature_FeatureChild_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GherkinDocument_Feature_FeatureChild)
	switch tag {
	case 1: // value.rule
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GherkinDocument_Feature_FeatureChild_Rule)
		err := b.DecodeMessage(msg)
		m.Value = &GherkinDocument_Feature_FeatureChild_Rule_{msg}
		return true, err
	case 2: // value.background
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GherkinDocument_Feature_Background)
		err := b.DecodeMessage(msg)
		m.Value = &GherkinDocument_Feature_FeatureChild_Background{msg}
		return true, err
	case 3: // value.scenario
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GherkinDocument_Feature_Scenario)
		err := b.DecodeMessage(msg)
		m.Value = &GherkinDocument_Feature_FeatureChild_Scenario{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GherkinDocument_Feature_FeatureChild_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GherkinDocument_Feature_FeatureChild)
	// value
	switch x := m.Value.(type) {
	case *GherkinDocument_Feature_FeatureChild_Rule_:
		s := proto.Size(x.Rule)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GherkinDocument_Feature_FeatureChild_Background:
		s := proto.Size(x.Background)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GherkinDocument_Feature_FeatureChild_Scenario:
		s := proto.Size(x.Scenario)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// *
// A `Rule` node
type GherkinDocument_Feature_FeatureChild_Rule struct {
	// The location of the `Rule` keyword
	Location    *Location                                         `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Keyword     string                                            `protobuf:"bytes,2,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Name        string                                            `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Description string                                            `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Children    []*GherkinDocument_Feature_FeatureChild_RuleChild `protobuf:"bytes,5,rep,name=children" json:"children,omitempty"`
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) Reset() {
	*m = GherkinDocument_Feature_FeatureChild_Rule{}
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_FeatureChild_Rule) ProtoMessage()    {}
func (*GherkinDocument_Feature_FeatureChild_Rule) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{5, 1, 1, 0}
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) GetChildren() []*GherkinDocument_Feature_FeatureChild_RuleChild {
	if m != nil {
		return m.Children
	}
	return nil
}

type GherkinDocument_Feature_FeatureChild_RuleChild struct {
	// Types that are valid to be assigned to Value:
	//	*GherkinDocument_Feature_FeatureChild_RuleChild_Background
	//	*GherkinDocument_Feature_FeatureChild_RuleChild_Scenario
	Value isGherkinDocument_Feature_FeatureChild_RuleChild_Value `protobuf_oneof:"value"`
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) Reset() {
	*m = GherkinDocument_Feature_FeatureChild_RuleChild{}
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild) String() string {
	return proto.CompactTextString(m)
}
func (*GherkinDocument_Feature_FeatureChild_RuleChild) ProtoMessage() {}
func (*GherkinDocument_Feature_FeatureChild_RuleChild) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{5, 1, 1, 1}
}

type isGherkinDocument_Feature_FeatureChild_RuleChild_Value interface {
	isGherkinDocument_Feature_FeatureChild_RuleChild_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type GherkinDocument_Feature_FeatureChild_RuleChild_Background struct {
	Background *GherkinDocument_Feature_Background `protobuf:"bytes,1,opt,name=background,oneof"`
}
type GherkinDocument_Feature_FeatureChild_RuleChild_Scenario struct {
	Scenario *GherkinDocument_Feature_Scenario `protobuf:"bytes,2,opt,name=scenario,oneof"`
}

func (*GherkinDocument_Feature_FeatureChild_RuleChild_Background) isGherkinDocument_Feature_FeatureChild_RuleChild_Value() {
}
func (*GherkinDocument_Feature_FeatureChild_RuleChild_Scenario) isGherkinDocument_Feature_FeatureChild_RuleChild_Value() {
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) GetValue() isGherkinDocument_Feature_FeatureChild_RuleChild_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) GetBackground() *GherkinDocument_Feature_Background {
	if x, ok := m.GetValue().(*GherkinDocument_Feature_FeatureChild_RuleChild_Background); ok {
		return x.Background
	}
	return nil
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) GetScenario() *GherkinDocument_Feature_Scenario {
	if x, ok := m.GetValue().(*GherkinDocument_Feature_FeatureChild_RuleChild_Scenario); ok {
		return x.Scenario
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GherkinDocument_Feature_FeatureChild_RuleChild) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GherkinDocument_Feature_FeatureChild_RuleChild_OneofMarshaler, _GherkinDocument_Feature_FeatureChild_RuleChild_OneofUnmarshaler, _GherkinDocument_Feature_FeatureChild_RuleChild_OneofSizer, []interface{}{
		(*GherkinDocument_Feature_FeatureChild_RuleChild_Background)(nil),
		(*GherkinDocument_Feature_FeatureChild_RuleChild_Scenario)(nil),
	}
}

func _GherkinDocument_Feature_FeatureChild_RuleChild_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GherkinDocument_Feature_FeatureChild_RuleChild)
	// value
	switch x := m.Value.(type) {
	case *GherkinDocument_Feature_FeatureChild_RuleChild_Background:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Background); err != nil {
			return err
		}
	case *GherkinDocument_Feature_FeatureChild_RuleChild_Scenario:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Scenario); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GherkinDocument_Feature_FeatureChild_RuleChild.Value has unexpected type %T", x)
	}
	return nil
}

func _GherkinDocument_Feature_FeatureChild_RuleChild_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GherkinDocument_Feature_FeatureChild_RuleChild)
	switch tag {
	case 1: // value.background
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GherkinDocument_Feature_Background)
		err := b.DecodeMessage(msg)
		m.Value = &GherkinDocument_Feature_FeatureChild_RuleChild_Background{msg}
		return true, err
	case 2: // value.scenario
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GherkinDocument_Feature_Scenario)
		err := b.DecodeMessage(msg)
		m.Value = &GherkinDocument_Feature_FeatureChild_RuleChild_Scenario{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GherkinDocument_Feature_FeatureChild_RuleChild_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GherkinDocument_Feature_FeatureChild_RuleChild)
	// value
	switch x := m.Value.(type) {
	case *GherkinDocument_Feature_FeatureChild_RuleChild_Background:
		s := proto.Size(x.Background)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GherkinDocument_Feature_FeatureChild_RuleChild_Scenario:
		s := proto.Size(x.Scenario)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GherkinDocument_Feature_Background struct {
	// The location of the `Background` keyword
	Location    *Location                       `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Keyword     string                          `protobuf:"bytes,2,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Name        string                          `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Description string                          `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Steps       []*GherkinDocument_Feature_Step `protobuf:"bytes,5,rep,name=steps" json:"steps,omitempty"`
}

func (m *GherkinDocument_Feature_Background) Reset()         { *m = GherkinDocument_Feature_Background{} }
func (m *GherkinDocument_Feature_Background) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Background) ProtoMessage()    {}
func (*GherkinDocument_Feature_Background) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{5, 1, 2}
}

func (m *GherkinDocument_Feature_Background) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Background) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *GherkinDocument_Feature_Background) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GherkinDocument_Feature_Background) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GherkinDocument_Feature_Background) GetSteps() []*GherkinDocument_Feature_Step {
	if m != nil {
		return m.Steps
	}
	return nil
}

type GherkinDocument_Feature_Scenario struct {
	// The location of the `Scenario` keyword
	Location    *Location                                    `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Tags        []*GherkinDocument_Feature_Tag               `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty"`
	Keyword     string                                       `protobuf:"bytes,3,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Name        string                                       `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Description string                                       `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	Steps       []*GherkinDocument_Feature_Step              `protobuf:"bytes,6,rep,name=steps" json:"steps,omitempty"`
	Examples    []*GherkinDocument_Feature_Scenario_Examples `protobuf:"bytes,7,rep,name=examples" json:"examples,omitempty"`
}

func (m *GherkinDocument_Feature_Scenario) Reset()         { *m = GherkinDocument_Feature_Scenario{} }
func (m *GherkinDocument_Feature_Scenario) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Scenario) ProtoMessage()    {}
func (*GherkinDocument_Feature_Scenario) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{5, 1, 3}
}

func (m *GherkinDocument_Feature_Scenario) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario) GetTags() []*GherkinDocument_Feature_Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *GherkinDocument_Feature_Scenario) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GherkinDocument_Feature_Scenario) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GherkinDocument_Feature_Scenario) GetSteps() []*GherkinDocument_Feature_Step {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario) GetExamples() []*GherkinDocument_Feature_Scenario_Examples {
	if m != nil {
		return m.Examples
	}
	return nil
}

type GherkinDocument_Feature_Scenario_Examples struct {
	// The location of the `Examples` keyword
	Location    *Location                           `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Tags        []*GherkinDocument_Feature_Tag      `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty"`
	Keyword     string                              `protobuf:"bytes,3,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Name        string                              `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Description string                              `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	TableHeader *GherkinDocument_Feature_TableRow   `protobuf:"bytes,6,opt,name=table_header,json=tableHeader" json:"table_header,omitempty"`
	TableBody   []*GherkinDocument_Feature_TableRow `protobuf:"bytes,7,rep,name=table_body,json=tableBody" json:"table_body,omitempty"`
}

func (m *GherkinDocument_Feature_Scenario_Examples) Reset() {
	*m = GherkinDocument_Feature_Scenario_Examples{}
}
func (m *GherkinDocument_Feature_Scenario_Examples) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Scenario_Examples) ProtoMessage()    {}
func (*GherkinDocument_Feature_Scenario_Examples) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{5, 1, 3, 0}
}

func (m *GherkinDocument_Feature_Scenario_Examples) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario_Examples) GetTags() []*GherkinDocument_Feature_Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario_Examples) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *GherkinDocument_Feature_Scenario_Examples) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GherkinDocument_Feature_Scenario_Examples) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GherkinDocument_Feature_Scenario_Examples) GetTableHeader() *GherkinDocument_Feature_TableRow {
	if m != nil {
		return m.TableHeader
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario_Examples) GetTableBody() []*GherkinDocument_Feature_TableRow {
	if m != nil {
		return m.TableBody
	}
	return nil
}

// A row in a table
type GherkinDocument_Feature_TableRow struct {
	// The location of the first cell in the row
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	// Cells in the row
	Cells []*GherkinDocument_Feature_TableRow_TableCell `protobuf:"bytes,2,rep,name=cells" json:"cells,omitempty"`
}

func (m *GherkinDocument_Feature_TableRow) Reset()         { *m = GherkinDocument_Feature_TableRow{} }
func (m *GherkinDocument_Feature_TableRow) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_TableRow) ProtoMessage()    {}
func (*GherkinDocument_Feature_TableRow) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{5, 1, 4}
}

func (m *GherkinDocument_Feature_TableRow) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_TableRow) GetCells() []*GherkinDocument_Feature_TableRow_TableCell {
	if m != nil {
		return m.Cells
	}
	return nil
}

// A cell in a `TableRow`
type GherkinDocument_Feature_TableRow_TableCell struct {
	// The location of the cell
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	// The value of the cell
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *GherkinDocument_Feature_TableRow_TableCell) Reset() {
	*m = GherkinDocument_Feature_TableRow_TableCell{}
}
func (m *GherkinDocument_Feature_TableRow_TableCell) String() string {
	return proto.CompactTextString(m)
}
func (*GherkinDocument_Feature_TableRow_TableCell) ProtoMessage() {}
func (*GherkinDocument_Feature_TableRow_TableCell) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{5, 1, 4, 0}
}

func (m *GherkinDocument_Feature_TableRow_TableCell) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_TableRow_TableCell) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// A step
type GherkinDocument_Feature_Step struct {
	// The location of the steps' `keyword`
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Keyword  string    `protobuf:"bytes,2,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Text     string    `protobuf:"bytes,3,opt,name=text,proto3" json:"text,omitempty"`
	// Types that are valid to be assigned to Argument:
	//	*GherkinDocument_Feature_Step_DocString_
	//	*GherkinDocument_Feature_Step_DataTable_
	Argument isGherkinDocument_Feature_Step_Argument `protobuf_oneof:"argument"`
}

func (m *GherkinDocument_Feature_Step) Reset()         { *m = GherkinDocument_Feature_Step{} }
func (m *GherkinDocument_Feature_Step) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Step) ProtoMessage()    {}
func (*GherkinDocument_Feature_Step) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{5, 1, 5}
}

type isGherkinDocument_Feature_Step_Argument interface {
	isGherkinDocument_Feature_Step_Argument()
	MarshalTo([]byte) (int, error)
	Size() int
}

type GherkinDocument_Feature_Step_DocString_ struct {
	DocString *GherkinDocument_Feature_Step_DocString `protobuf:"bytes,5,opt,name=doc_string,json=docString,oneof"`
}
type GherkinDocument_Feature_Step_DataTable_ struct {
	DataTable *GherkinDocument_Feature_Step_DataTable `protobuf:"bytes,6,opt,name=data_table,json=dataTable,oneof"`
}

func (*GherkinDocument_Feature_Step_DocString_) isGherkinDocument_Feature_Step_Argument() {}
func (*GherkinDocument_Feature_Step_DataTable_) isGherkinDocument_Feature_Step_Argument() {}

func (m *GherkinDocument_Feature_Step) GetArgument() isGherkinDocument_Feature_Step_Argument {
	if m != nil {
		return m.Argument
	}
	return nil
}

func (m *GherkinDocument_Feature_Step) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Step) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *GherkinDocument_Feature_Step) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *GherkinDocument_Feature_Step) GetDocString() *GherkinDocument_Feature_Step_DocString {
	if x, ok := m.GetArgument().(*GherkinDocument_Feature_Step_DocString_); ok {
		return x.DocString
	}
	return nil
}

func (m *GherkinDocument_Feature_Step) GetDataTable() *GherkinDocument_Feature_Step_DataTable {
	if x, ok := m.GetArgument().(*GherkinDocument_Feature_Step_DataTable_); ok {
		return x.DataTable
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GherkinDocument_Feature_Step) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GherkinDocument_Feature_Step_OneofMarshaler, _GherkinDocument_Feature_Step_OneofUnmarshaler, _GherkinDocument_Feature_Step_OneofSizer, []interface{}{
		(*GherkinDocument_Feature_Step_DocString_)(nil),
		(*GherkinDocument_Feature_Step_DataTable_)(nil),
	}
}

func _GherkinDocument_Feature_Step_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GherkinDocument_Feature_Step)
	// argument
	switch x := m.Argument.(type) {
	case *GherkinDocument_Feature_Step_DocString_:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DocString); err != nil {
			return err
		}
	case *GherkinDocument_Feature_Step_DataTable_:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DataTable); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GherkinDocument_Feature_Step.Argument has unexpected type %T", x)
	}
	return nil
}

func _GherkinDocument_Feature_Step_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GherkinDocument_Feature_Step)
	switch tag {
	case 5: // argument.doc_string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GherkinDocument_Feature_Step_DocString)
		err := b.DecodeMessage(msg)
		m.Argument = &GherkinDocument_Feature_Step_DocString_{msg}
		return true, err
	case 6: // argument.data_table
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GherkinDocument_Feature_Step_DataTable)
		err := b.DecodeMessage(msg)
		m.Argument = &GherkinDocument_Feature_Step_DataTable_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GherkinDocument_Feature_Step_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GherkinDocument_Feature_Step)
	// argument
	switch x := m.Argument.(type) {
	case *GherkinDocument_Feature_Step_DocString_:
		s := proto.Size(x.DocString)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GherkinDocument_Feature_Step_DataTable_:
		s := proto.Size(x.DataTable)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GherkinDocument_Feature_Step_DataTable struct {
	Location *Location                           `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Rows     []*GherkinDocument_Feature_TableRow `protobuf:"bytes,2,rep,name=rows" json:"rows,omitempty"`
}

func (m *GherkinDocument_Feature_Step_DataTable) Reset() {
	*m = GherkinDocument_Feature_Step_DataTable{}
}
func (m *GherkinDocument_Feature_Step_DataTable) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Step_DataTable) ProtoMessage()    {}
func (*GherkinDocument_Feature_Step_DataTable) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{5, 1, 5, 0}
}

func (m *GherkinDocument_Feature_Step_DataTable) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Step_DataTable) GetRows() []*GherkinDocument_Feature_TableRow {
	if m != nil {
		return m.Rows
	}
	return nil
}

type GherkinDocument_Feature_Step_DocString struct {
	Location    *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	ContentType string    `protobuf:"bytes,2,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	Content     string    `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
	Delimiter   string    `protobuf:"bytes,4,opt,name=delimiter,proto3" json:"delimiter,omitempty"`
}

func (m *GherkinDocument_Feature_Step_DocString) Reset() {
	*m = GherkinDocument_Feature_Step_DocString{}
}
func (m *GherkinDocument_Feature_Step_DocString) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Step_DocString) ProtoMessage()    {}
func (*GherkinDocument_Feature_Step_DocString) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{5, 1, 5, 1}
}

func (m *GherkinDocument_Feature_Step_DocString) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Step_DocString) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *GherkinDocument_Feature_Step_DocString) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *GherkinDocument_Feature_Step_DocString) GetDelimiter() string {
	if m != nil {
		return m.Delimiter
	}
	return ""
}

// *
// An attachment represents any kind of data associated with a line in a
// [Source](#io.cucumber.messages.Source) file. It can be used for:
//
// * Syntax errors during parse time
// * Screenshots captured and attached during execution
// * Logs captured and attached during execution
// * Runtime errors raised/thrown during execution (TODO: Conflicts with `TestResult#message`?)
type Attachment struct {
	Source *SourceReference `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	Data   string           `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Media  *Media           `protobuf:"bytes,3,opt,name=media" json:"media,omitempty"`
}

func (m *Attachment) Reset()                    { *m = Attachment{} }
func (m *Attachment) String() string            { return proto.CompactTextString(m) }
func (*Attachment) ProtoMessage()               {}
func (*Attachment) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{6} }

func (m *Attachment) GetSource() *SourceReference {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Attachment) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *Attachment) GetMedia() *Media {
	if m != nil {
		return m.Media
	}
	return nil
}

// *
// A `Pickle` represents a test case Cucumber can *execute*. It is typically derived
// from another format, such as [GherkinDocument](#io.cucumber.messages.GherkinDocument).
// In the future a `Pickle` may be derived from other formats such as Markdown or
// Excel files.
//
// By making `Pickle` the main data structure Cucumber uses for execution, the
// implementation of Cucumber itself becomes simpler, as it doesn't have to deal
// with the complex structure of a [GherkinDocument](#io.cucumber.messages.GherkinDocument).
type Pickle struct {
	// *
	// A unique id for the pickle. This is a [SHA1](https://en.wikipedia.org/wiki/SHA-1) hash
	// from the source data and the `locations` of the pickle.
	// This ID will change if source the file is modified.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The uri of the source file
	Uri string `protobuf:"bytes,2,opt,name=uri,proto3" json:"uri,omitempty"`
	// The name of the pickle
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// The language of the pickle
	Language string `protobuf:"bytes,4,opt,name=language,proto3" json:"language,omitempty"`
	// One or more steps
	Steps []*Pickle_PickleStep `protobuf:"bytes,5,rep,name=steps" json:"steps,omitempty"`
	// *
	// One or more tags. If this pickle is constructed from a Gherkin document,
	// It includes inherited tags from the `Feature` as well.
	Tags []*Pickle_PickleTag `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
	// *
	// The source locations of the pickle. The last one represents the unique
	// line number. A pickle constructed from `Examples` will have the first
	// location originating from the `Step`, and the second from the table row.
	Locations []*Location `protobuf:"bytes,7,rep,name=locations" json:"locations,omitempty"`
}

func (m *Pickle) Reset()                    { *m = Pickle{} }
func (m *Pickle) String() string            { return proto.CompactTextString(m) }
func (*Pickle) ProtoMessage()               {}
func (*Pickle) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{7} }

func (m *Pickle) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Pickle) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *Pickle) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Pickle) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *Pickle) GetSteps() []*Pickle_PickleStep {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *Pickle) GetTags() []*Pickle_PickleTag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Pickle) GetLocations() []*Location {
	if m != nil {
		return m.Locations
	}
	return nil
}

// *
// A tag
type Pickle_PickleTag struct {
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Name     string    `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Pickle_PickleTag) Reset()                    { *m = Pickle_PickleTag{} }
func (m *Pickle_PickleTag) String() string            { return proto.CompactTextString(m) }
func (*Pickle_PickleTag) ProtoMessage()               {}
func (*Pickle_PickleTag) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{7, 0} }

func (m *Pickle_PickleTag) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Pickle_PickleTag) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// *
// An executable step
type Pickle_PickleStep struct {
	Text      string      `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	Locations []*Location `protobuf:"bytes,2,rep,name=locations" json:"locations,omitempty"`
	// An optional argument
	Argument *PickleStepArgument `protobuf:"bytes,5,opt,name=argument" json:"argument,omitempty"`
}

func (m *Pickle_PickleStep) Reset()                    { *m = Pickle_PickleStep{} }
func (m *Pickle_PickleStep) String() string            { return proto.CompactTextString(m) }
func (*Pickle_PickleStep) ProtoMessage()               {}
func (*Pickle_PickleStep) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{7, 1} }

func (m *Pickle_PickleStep) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Pickle_PickleStep) GetLocations() []*Location {
	if m != nil {
		return m.Locations
	}
	return nil
}

func (m *Pickle_PickleStep) GetArgument() *PickleStepArgument {
	if m != nil {
		return m.Argument
	}
	return nil
}

// *
// A wrapper for either a doc string or a table.
type PickleStepArgument struct {
	// Types that are valid to be assigned to Message:
	//	*PickleStepArgument_DocString
	//	*PickleStepArgument_DataTable
	Message isPickleStepArgument_Message `protobuf_oneof:"message"`
}

func (m *PickleStepArgument) Reset()                    { *m = PickleStepArgument{} }
func (m *PickleStepArgument) String() string            { return proto.CompactTextString(m) }
func (*PickleStepArgument) ProtoMessage()               {}
func (*PickleStepArgument) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{8} }

type isPickleStepArgument_Message interface {
	isPickleStepArgument_Message()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PickleStepArgument_DocString struct {
	DocString *PickleStepArgument_PickleDocString `protobuf:"bytes,1,opt,name=doc_string,json=docString,oneof"`
}
type PickleStepArgument_DataTable struct {
	DataTable *PickleStepArgument_PickleTable `protobuf:"bytes,2,opt,name=data_table,json=dataTable,oneof"`
}

func (*PickleStepArgument_DocString) isPickleStepArgument_Message() {}
func (*PickleStepArgument_DataTable) isPickleStepArgument_Message() {}

func (m *PickleStepArgument) GetMessage() isPickleStepArgument_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *PickleStepArgument) GetDocString() *PickleStepArgument_PickleDocString {
	if x, ok := m.GetMessage().(*PickleStepArgument_DocString); ok {
		return x.DocString
	}
	return nil
}

func (m *PickleStepArgument) GetDataTable() *PickleStepArgument_PickleTable {
	if x, ok := m.GetMessage().(*PickleStepArgument_DataTable); ok {
		return x.DataTable
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PickleStepArgument) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PickleStepArgument_OneofMarshaler, _PickleStepArgument_OneofUnmarshaler, _PickleStepArgument_OneofSizer, []interface{}{
		(*PickleStepArgument_DocString)(nil),
		(*PickleStepArgument_DataTable)(nil),
	}
}

func _PickleStepArgument_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PickleStepArgument)
	// message
	switch x := m.Message.(type) {
	case *PickleStepArgument_DocString:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DocString); err != nil {
			return err
		}
	case *PickleStepArgument_DataTable:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DataTable); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PickleStepArgument.Message has unexpected type %T", x)
	}
	return nil
}

func _PickleStepArgument_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PickleStepArgument)
	switch tag {
	case 1: // message.doc_string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PickleStepArgument_PickleDocString)
		err := b.DecodeMessage(msg)
		m.Message = &PickleStepArgument_DocString{msg}
		return true, err
	case 2: // message.data_table
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PickleStepArgument_PickleTable)
		err := b.DecodeMessage(msg)
		m.Message = &PickleStepArgument_DataTable{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PickleStepArgument_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PickleStepArgument)
	// message
	switch x := m.Message.(type) {
	case *PickleStepArgument_DocString:
		s := proto.Size(x.DocString)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PickleStepArgument_DataTable:
		s := proto.Size(x.DataTable)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PickleStepArgument_PickleDocString struct {
	Location    *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	ContentType string    `protobuf:"bytes,2,opt,name=contentType,proto3" json:"contentType,omitempty"`
	Content     string    `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *PickleStepArgument_PickleDocString) Reset()         { *m = PickleStepArgument_PickleDocString{} }
func (m *PickleStepArgument_PickleDocString) String() string { return proto.CompactTextString(m) }
func (*PickleStepArgument_PickleDocString) ProtoMessage()    {}
func (*PickleStepArgument_PickleDocString) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{8, 0}
}

func (m *PickleStepArgument_PickleDocString) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *PickleStepArgument_PickleDocString) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *PickleStepArgument_PickleDocString) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

type PickleStepArgument_PickleTable struct {
	Rows []*PickleStepArgument_PickleTable_PickleTableRow `protobuf:"bytes,1,rep,name=rows" json:"rows,omitempty"`
}

func (m *PickleStepArgument_PickleTable) Reset()         { *m = PickleStepArgument_PickleTable{} }
func (m *PickleStepArgument_PickleTable) String() string { return proto.CompactTextString(m) }
func (*PickleStepArgument_PickleTable) ProtoMessage()    {}
func (*PickleStepArgument_PickleTable) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{8, 1}
}

func (m *PickleStepArgument_PickleTable) GetRows() []*PickleStepArgument_PickleTable_PickleTableRow {
	if m != nil {
		return m.Rows
	}
	return nil
}

type PickleStepArgument_PickleTable_PickleTableRow struct {
	Cells []*PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell `protobuf:"bytes,1,rep,name=cells" json:"cells,omitempty"`
}

func (m *PickleStepArgument_PickleTable_PickleTableRow) Reset() {
	*m = PickleStepArgument_PickleTable_PickleTableRow{}
}
func (m *PickleStepArgument_PickleTable_PickleTableRow) String() string {
	return proto.CompactTextString(m)
}
func (*PickleStepArgument_PickleTable_PickleTableRow) ProtoMessage() {}
func (*PickleStepArgument_PickleTable_PickleTableRow) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{8, 1, 0}
}

func (m *PickleStepArgument_PickleTable_PickleTableRow) GetCells() []*PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell {
	if m != nil {
		return m.Cells
	}
	return nil
}

type PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell struct {
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Value    string    `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) Reset() {
	*m = PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell{}
}
func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) String() string {
	return proto.CompactTextString(m)
}
func (*PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) ProtoMessage() {}
func (*PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{8, 1, 0, 0}
}

func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type PickleAccepted struct {
	PickleId string `protobuf:"bytes,1,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
}

func (m *PickleAccepted) Reset()                    { *m = PickleAccepted{} }
func (m *PickleAccepted) String() string            { return proto.CompactTextString(m) }
func (*PickleAccepted) ProtoMessage()               {}
func (*PickleAccepted) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{9} }

func (m *PickleAccepted) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

type PickleRejected struct {
	PickleId string `protobuf:"bytes,2,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
}

func (m *PickleRejected) Reset()                    { *m = PickleRejected{} }
func (m *PickleRejected) String() string            { return proto.CompactTextString(m) }
func (*PickleRejected) ProtoMessage()               {}
func (*PickleRejected) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{10} }

func (m *PickleRejected) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

type TestRunStarted struct {
	Timestamp *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *TestRunStarted) Reset()                    { *m = TestRunStarted{} }
func (m *TestRunStarted) String() string            { return proto.CompactTextString(m) }
func (*TestRunStarted) ProtoMessage()               {}
func (*TestRunStarted) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{11} }

func (m *TestRunStarted) GetTimestamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type TestCasePreparedStep struct {
	SourceLocation *SourceReference `protobuf:"bytes,1,opt,name=sourceLocation" json:"sourceLocation,omitempty"`
	ActionLocation *SourceReference `protobuf:"bytes,2,opt,name=actionLocation" json:"actionLocation,omitempty"`
}

func (m *TestCasePreparedStep) Reset()                    { *m = TestCasePreparedStep{} }
func (m *TestCasePreparedStep) String() string            { return proto.CompactTextString(m) }
func (*TestCasePreparedStep) ProtoMessage()               {}
func (*TestCasePreparedStep) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{12} }

func (m *TestCasePreparedStep) GetSourceLocation() *SourceReference {
	if m != nil {
		return m.SourceLocation
	}
	return nil
}

func (m *TestCasePreparedStep) GetActionLocation() *SourceReference {
	if m != nil {
		return m.ActionLocation
	}
	return nil
}

type TestCasePrepared struct {
	PickleId string                  `protobuf:"bytes,1,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
	Steps    []*TestCasePreparedStep `protobuf:"bytes,2,rep,name=steps" json:"steps,omitempty"`
}

func (m *TestCasePrepared) Reset()                    { *m = TestCasePrepared{} }
func (m *TestCasePrepared) String() string            { return proto.CompactTextString(m) }
func (*TestCasePrepared) ProtoMessage()               {}
func (*TestCasePrepared) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{13} }

func (m *TestCasePrepared) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

func (m *TestCasePrepared) GetSteps() []*TestCasePreparedStep {
	if m != nil {
		return m.Steps
	}
	return nil
}

type TestCaseStarted struct {
	PickleId  string                     `protobuf:"bytes,1,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
	Timestamp *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`
	Platform  *TestCaseStarted_Platform  `protobuf:"bytes,3,opt,name=platform" json:"platform,omitempty"`
}

func (m *TestCaseStarted) Reset()                    { *m = TestCaseStarted{} }
func (m *TestCaseStarted) String() string            { return proto.CompactTextString(m) }
func (*TestCaseStarted) ProtoMessage()               {}
func (*TestCaseStarted) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{14} }

func (m *TestCaseStarted) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

func (m *TestCaseStarted) GetTimestamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *TestCaseStarted) GetPlatform() *TestCaseStarted_Platform {
	if m != nil {
		return m.Platform
	}
	return nil
}

type TestCaseStarted_Platform struct {
	// The runner implementation. For example "SpecFlow", "Cucumber-JVM", "Behat" etc.
	Implementation string `protobuf:"bytes,1,opt,name=implementation,proto3" json:"implementation,omitempty"`
	// The version of the runner
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// The operating system
	Os string `protobuf:"bytes,3,opt,name=os,proto3" json:"os,omitempty"`
	// The CPU architecture
	Cpu string `protobuf:"bytes,4,opt,name=cpu,proto3" json:"cpu,omitempty"`
}

func (m *TestCaseStarted_Platform) Reset()         { *m = TestCaseStarted_Platform{} }
func (m *TestCaseStarted_Platform) String() string { return proto.CompactTextString(m) }
func (*TestCaseStarted_Platform) ProtoMessage()    {}
func (*TestCaseStarted_Platform) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{14, 0}
}

func (m *TestCaseStarted_Platform) GetImplementation() string {
	if m != nil {
		return m.Implementation
	}
	return ""
}

func (m *TestCaseStarted_Platform) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *TestCaseStarted_Platform) GetOs() string {
	if m != nil {
		return m.Os
	}
	return ""
}

func (m *TestCaseStarted_Platform) GetCpu() string {
	if m != nil {
		return m.Cpu
	}
	return ""
}

type TestCaseFinished struct {
	PickleId   string                     `protobuf:"bytes,1,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
	Timestamp  *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`
	TestResult *TestResult                `protobuf:"bytes,3,opt,name=testResult" json:"testResult,omitempty"`
}

func (m *TestCaseFinished) Reset()                    { *m = TestCaseFinished{} }
func (m *TestCaseFinished) String() string            { return proto.CompactTextString(m) }
func (*TestCaseFinished) ProtoMessage()               {}
func (*TestCaseFinished) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{15} }

func (m *TestCaseFinished) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

func (m *TestCaseFinished) GetTimestamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *TestCaseFinished) GetTestResult() *TestResult {
	if m != nil {
		return m.TestResult
	}
	return nil
}

type TestStepStarted struct {
	PickleId  string                     `protobuf:"bytes,1,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
	Index     uint32                     `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	Timestamp *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *TestStepStarted) Reset()                    { *m = TestStepStarted{} }
func (m *TestStepStarted) String() string            { return proto.CompactTextString(m) }
func (*TestStepStarted) ProtoMessage()               {}
func (*TestStepStarted) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{16} }

func (m *TestStepStarted) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

func (m *TestStepStarted) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *TestStepStarted) GetTimestamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type TestStepFinished struct {
	PickleId   string                     `protobuf:"bytes,1,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
	Index      uint32                     `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	TestResult *TestResult                `protobuf:"bytes,3,opt,name=testResult" json:"testResult,omitempty"`
	Timestamp  *google_protobuf.Timestamp `protobuf:"bytes,4,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *TestStepFinished) Reset()                    { *m = TestStepFinished{} }
func (m *TestStepFinished) String() string            { return proto.CompactTextString(m) }
func (*TestStepFinished) ProtoMessage()               {}
func (*TestStepFinished) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{17} }

func (m *TestStepFinished) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

func (m *TestStepFinished) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *TestStepFinished) GetTestResult() *TestResult {
	if m != nil {
		return m.TestResult
	}
	return nil
}

func (m *TestStepFinished) GetTimestamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type TestHookStarted struct {
	PickleId  string                     `protobuf:"bytes,1,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
	Timestamp *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *TestHookStarted) Reset()                    { *m = TestHookStarted{} }
func (m *TestHookStarted) String() string            { return proto.CompactTextString(m) }
func (*TestHookStarted) ProtoMessage()               {}
func (*TestHookStarted) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{18} }

func (m *TestHookStarted) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

func (m *TestHookStarted) GetTimestamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type TestHookFinished struct {
	PickleId   string                     `protobuf:"bytes,1,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
	TestResult *TestResult                `protobuf:"bytes,2,opt,name=testResult" json:"testResult,omitempty"`
	Timestamp  *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *TestHookFinished) Reset()                    { *m = TestHookFinished{} }
func (m *TestHookFinished) String() string            { return proto.CompactTextString(m) }
func (*TestHookFinished) ProtoMessage()               {}
func (*TestHookFinished) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{19} }

func (m *TestHookFinished) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

func (m *TestHookFinished) GetTestResult() *TestResult {
	if m != nil {
		return m.TestResult
	}
	return nil
}

func (m *TestHookFinished) GetTimestamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type TestResult struct {
	Status              TestResult_Status `protobuf:"varint,1,opt,name=status,proto3,enum=io.cucumber.messages.TestResult_Status" json:"status,omitempty"`
	Message             string            `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	DurationNanoseconds uint64            `protobuf:"varint,3,opt,name=durationNanoseconds,proto3" json:"durationNanoseconds,omitempty"`
}

func (m *TestResult) Reset()                    { *m = TestResult{} }
func (m *TestResult) String() string            { return proto.CompactTextString(m) }
func (*TestResult) ProtoMessage()               {}
func (*TestResult) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{20} }

func (m *TestResult) GetStatus() TestResult_Status {
	if m != nil {
		return m.Status
	}
	return TestResult_AMBIGUOUS
}

func (m *TestResult) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *TestResult) GetDurationNanoseconds() uint64 {
	if m != nil {
		return m.DurationNanoseconds
	}
	return 0
}

type TestRunFinished struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *TestRunFinished) Reset()                    { *m = TestRunFinished{} }
func (m *TestRunFinished) String() string            { return proto.CompactTextString(m) }
func (*TestRunFinished) ProtoMessage()               {}
func (*TestRunFinished) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{21} }

func (m *TestRunFinished) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type CommandStart struct {
	BaseDirectory     string             `protobuf:"bytes,2,opt,name=baseDirectory,proto3" json:"baseDirectory,omitempty"`
	SourcesConfig     *SourcesConfig     `protobuf:"bytes,3,opt,name=sourcesConfig" json:"sourcesConfig,omitempty"`
	RuntimeConfig     *RuntimeConfig     `protobuf:"bytes,4,opt,name=runtimeConfig" json:"runtimeConfig,omitempty"`
	SupportCodeConfig *SupportCodeConfig `protobuf:"bytes,5,opt,name=supportCodeConfig" json:"supportCodeConfig,omitempty"`
}

func (m *CommandStart) Reset()                    { *m = CommandStart{} }
func (m *CommandStart) String() string            { return proto.CompactTextString(m) }
func (*CommandStart) ProtoMessage()               {}
func (*CommandStart) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{22} }

func (m *CommandStart) GetBaseDirectory() string {
	if m != nil {
		return m.BaseDirectory
	}
	return ""
}

func (m *CommandStart) GetSourcesConfig() *SourcesConfig {
	if m != nil {
		return m.SourcesConfig
	}
	return nil
}

func (m *CommandStart) GetRuntimeConfig() *RuntimeConfig {
	if m != nil {
		return m.RuntimeConfig
	}
	return nil
}

func (m *CommandStart) GetSupportCodeConfig() *SupportCodeConfig {
	if m != nil {
		return m.SupportCodeConfig
	}
	return nil
}

type SourcesConfig struct {
	AbsolutePaths []string             `protobuf:"bytes,1,rep,name=absolutePaths" json:"absolutePaths,omitempty"`
	Language      string               `protobuf:"bytes,2,opt,name=language,proto3" json:"language,omitempty"`
	Filters       *SourcesFilterConfig `protobuf:"bytes,3,opt,name=filters" json:"filters,omitempty"`
	Order         *SourcesOrder        `protobuf:"bytes,4,opt,name=order" json:"order,omitempty"`
}

func (m *SourcesConfig) Reset()                    { *m = SourcesConfig{} }
func (m *SourcesConfig) String() string            { return proto.CompactTextString(m) }
func (*SourcesConfig) ProtoMessage()               {}
func (*SourcesConfig) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{23} }

func (m *SourcesConfig) GetAbsolutePaths() []string {
	if m != nil {
		return m.AbsolutePaths
	}
	return nil
}

func (m *SourcesConfig) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *SourcesConfig) GetFilters() *SourcesFilterConfig {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *SourcesConfig) GetOrder() *SourcesOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

type SourcesFilterConfig struct {
	TagExpression          string               `protobuf:"bytes,1,opt,name=tagExpression,proto3" json:"tagExpression,omitempty"`
	NameRegularExpressions []string             `protobuf:"bytes,2,rep,name=nameRegularExpressions" json:"nameRegularExpressions,omitempty"`
	UriToLinesMapping      []*UriToLinesMapping `protobuf:"bytes,3,rep,name=uriToLinesMapping" json:"uriToLinesMapping,omitempty"`
}

func (m *SourcesFilterConfig) Reset()                    { *m = SourcesFilterConfig{} }
func (m *SourcesFilterConfig) String() string            { return proto.CompactTextString(m) }
func (*SourcesFilterConfig) ProtoMessage()               {}
func (*SourcesFilterConfig) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{24} }

func (m *SourcesFilterConfig) GetTagExpression() string {
	if m != nil {
		return m.TagExpression
	}
	return ""
}

func (m *SourcesFilterConfig) GetNameRegularExpressions() []string {
	if m != nil {
		return m.NameRegularExpressions
	}
	return nil
}

func (m *SourcesFilterConfig) GetUriToLinesMapping() []*UriToLinesMapping {
	if m != nil {
		return m.UriToLinesMapping
	}
	return nil
}

type UriToLinesMapping struct {
	AbsolutePath string   `protobuf:"bytes,1,opt,name=absolutePath,proto3" json:"absolutePath,omitempty"`
	Lines        []uint64 `protobuf:"varint,2,rep,packed,name=lines" json:"lines,omitempty"`
}

func (m *UriToLinesMapping) Reset()                    { *m = UriToLinesMapping{} }
func (m *UriToLinesMapping) String() string            { return proto.CompactTextString(m) }
func (*UriToLinesMapping) ProtoMessage()               {}
func (*UriToLinesMapping) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{25} }

func (m *UriToLinesMapping) GetAbsolutePath() string {
	if m != nil {
		return m.AbsolutePath
	}
	return ""
}

func (m *UriToLinesMapping) GetLines() []uint64 {
	if m != nil {
		return m.Lines
	}
	return nil
}

type SourcesOrder struct {
	Type SourcesOrderType `protobuf:"varint,1,opt,name=type,proto3,enum=io.cucumber.messages.SourcesOrderType" json:"type,omitempty"`
	Seed uint64           `protobuf:"varint,2,opt,name=seed,proto3" json:"seed,omitempty"`
}

func (m *SourcesOrder) Reset()                    { *m = SourcesOrder{} }
func (m *SourcesOrder) String() string            { return proto.CompactTextString(m) }
func (*SourcesOrder) ProtoMessage()               {}
func (*SourcesOrder) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{26} }

func (m *SourcesOrder) GetType() SourcesOrderType {
	if m != nil {
		return m.Type
	}
	return SourcesOrderType_ORDER_OF_DEFINITION
}

func (m *SourcesOrder) GetSeed() uint64 {
	if m != nil {
		return m.Seed
	}
	return 0
}

type RuntimeConfig struct {
	IsFailFast  bool   `protobuf:"varint,1,opt,name=isFailFast,proto3" json:"isFailFast,omitempty"`
	IsDryRun    bool   `protobuf:"varint,2,opt,name=isDryRun,proto3" json:"isDryRun,omitempty"`
	IsStrict    bool   `protobuf:"varint,3,opt,name=isStrict,proto3" json:"isStrict,omitempty"`
	MaxParallel uint64 `protobuf:"varint,4,opt,name=maxParallel,proto3" json:"maxParallel,omitempty"`
}

func (m *RuntimeConfig) Reset()                    { *m = RuntimeConfig{} }
func (m *RuntimeConfig) String() string            { return proto.CompactTextString(m) }
func (*RuntimeConfig) ProtoMessage()               {}
func (*RuntimeConfig) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{27} }

func (m *RuntimeConfig) GetIsFailFast() bool {
	if m != nil {
		return m.IsFailFast
	}
	return false
}

func (m *RuntimeConfig) GetIsDryRun() bool {
	if m != nil {
		return m.IsDryRun
	}
	return false
}

func (m *RuntimeConfig) GetIsStrict() bool {
	if m != nil {
		return m.IsStrict
	}
	return false
}

func (m *RuntimeConfig) GetMaxParallel() uint64 {
	if m != nil {
		return m.MaxParallel
	}
	return 0
}

type SupportCodeConfig struct {
	BeforeTestCaseHookDefinitionConfigs []*TestCaseHookDefinitionConfig `protobuf:"bytes,1,rep,name=beforeTestCaseHookDefinitionConfigs" json:"beforeTestCaseHookDefinitionConfigs,omitempty"`
	AfterTestCaseHookDefinitionConfigs  []*TestCaseHookDefinitionConfig `protobuf:"bytes,2,rep,name=afterTestCaseHookDefinitionConfigs" json:"afterTestCaseHookDefinitionConfigs,omitempty"`
	StepDefinitionConfigs               []*StepDefinitionConfig         `protobuf:"bytes,3,rep,name=stepDefinitionConfigs" json:"stepDefinitionConfigs,omitempty"`
	ParameterTypeConfigs                []*ParameterTypeConfig          `protobuf:"bytes,4,rep,name=parameterTypeConfigs" json:"parameterTypeConfigs,omitempty"`
}

func (m *SupportCodeConfig) Reset()                    { *m = SupportCodeConfig{} }
func (m *SupportCodeConfig) String() string            { return proto.CompactTextString(m) }
func (*SupportCodeConfig) ProtoMessage()               {}
func (*SupportCodeConfig) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{28} }

func (m *SupportCodeConfig) GetBeforeTestCaseHookDefinitionConfigs() []*TestCaseHookDefinitionConfig {
	if m != nil {
		return m.BeforeTestCaseHookDefinitionConfigs
	}
	return nil
}

func (m *SupportCodeConfig) GetAfterTestCaseHookDefinitionConfigs() []*TestCaseHookDefinitionConfig {
	if m != nil {
		return m.AfterTestCaseHookDefinitionConfigs
	}
	return nil
}

func (m *SupportCodeConfig) GetStepDefinitionConfigs() []*StepDefinitionConfig {
	if m != nil {
		return m.StepDefinitionConfigs
	}
	return nil
}

func (m *SupportCodeConfig) GetParameterTypeConfigs() []*ParameterTypeConfig {
	if m != nil {
		return m.ParameterTypeConfigs
	}
	return nil
}

type TestCaseHookDefinitionConfig struct {
	Id            string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	TagExpression string           `protobuf:"bytes,2,opt,name=tagExpression,proto3" json:"tagExpression,omitempty"`
	Location      *SourceReference `protobuf:"bytes,3,opt,name=location" json:"location,omitempty"`
}

func (m *TestCaseHookDefinitionConfig) Reset()         { *m = TestCaseHookDefinitionConfig{} }
func (m *TestCaseHookDefinitionConfig) String() string { return proto.CompactTextString(m) }
func (*TestCaseHookDefinitionConfig) ProtoMessage()    {}
func (*TestCaseHookDefinitionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{29}
}

func (m *TestCaseHookDefinitionConfig) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TestCaseHookDefinitionConfig) GetTagExpression() string {
	if m != nil {
		return m.TagExpression
	}
	return ""
}

func (m *TestCaseHookDefinitionConfig) GetLocation() *SourceReference {
	if m != nil {
		return m.Location
	}
	return nil
}

type StepDefinitionConfig struct {
	Id       string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Pattern  *StepDefinitionPattern `protobuf:"bytes,2,opt,name=pattern" json:"pattern,omitempty"`
	Location *SourceReference       `protobuf:"bytes,3,opt,name=location" json:"location,omitempty"`
}

func (m *StepDefinitionConfig) Reset()                    { *m = StepDefinitionConfig{} }
func (m *StepDefinitionConfig) String() string            { return proto.CompactTextString(m) }
func (*StepDefinitionConfig) ProtoMessage()               {}
func (*StepDefinitionConfig) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{30} }

func (m *StepDefinitionConfig) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *StepDefinitionConfig) GetPattern() *StepDefinitionPattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

func (m *StepDefinitionConfig) GetLocation() *SourceReference {
	if m != nil {
		return m.Location
	}
	return nil
}

type StepDefinitionPattern struct {
	Source string                    `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type   StepDefinitionPatternType `protobuf:"varint,2,opt,name=type,proto3,enum=io.cucumber.messages.StepDefinitionPatternType" json:"type,omitempty"`
}

func (m *StepDefinitionPattern) Reset()                    { *m = StepDefinitionPattern{} }
func (m *StepDefinitionPattern) String() string            { return proto.CompactTextString(m) }
func (*StepDefinitionPattern) ProtoMessage()               {}
func (*StepDefinitionPattern) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{31} }

func (m *StepDefinitionPattern) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *StepDefinitionPattern) GetType() StepDefinitionPatternType {
	if m != nil {
		return m.Type
	}
	return StepDefinitionPatternType_CUCUMBER_EXPRESSION
}

type ParameterTypeConfig struct {
	Name                            string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	RegularExpressions              []string `protobuf:"bytes,2,rep,name=regularExpressions" json:"regularExpressions,omitempty"`
	PreferForRegularExpressionMatch bool     `protobuf:"varint,3,opt,name=preferForRegularExpressionMatch,proto3" json:"preferForRegularExpressionMatch,omitempty"`
	UseForSnippets                  bool     `protobuf:"varint,4,opt,name=useForSnippets,proto3" json:"useForSnippets,omitempty"`
}

func (m *ParameterTypeConfig) Reset()                    { *m = ParameterTypeConfig{} }
func (m *ParameterTypeConfig) String() string            { return proto.CompactTextString(m) }
func (*ParameterTypeConfig) ProtoMessage()               {}
func (*ParameterTypeConfig) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{32} }

func (m *ParameterTypeConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ParameterTypeConfig) GetRegularExpressions() []string {
	if m != nil {
		return m.RegularExpressions
	}
	return nil
}

func (m *ParameterTypeConfig) GetPreferForRegularExpressionMatch() bool {
	if m != nil {
		return m.PreferForRegularExpressionMatch
	}
	return false
}

func (m *ParameterTypeConfig) GetUseForSnippets() bool {
	if m != nil {
		return m.UseForSnippets
	}
	return false
}

type CommandActionComplete struct {
	CompletedId string `protobuf:"bytes,1,opt,name=completedId,proto3" json:"completedId,omitempty"`
	// Types that are valid to be assigned to Result:
	//	*CommandActionComplete_TestResult
	//	*CommandActionComplete_Snippet
	Result isCommandActionComplete_Result `protobuf_oneof:"result"`
}

func (m *CommandActionComplete) Reset()                    { *m = CommandActionComplete{} }
func (m *CommandActionComplete) String() string            { return proto.CompactTextString(m) }
func (*CommandActionComplete) ProtoMessage()               {}
func (*CommandActionComplete) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{33} }

type isCommandActionComplete_Result interface {
	isCommandActionComplete_Result()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CommandActionComplete_TestResult struct {
	TestResult *TestResult `protobuf:"bytes,2,opt,name=testResult,oneof"`
}
type CommandActionComplete_Snippet struct {
	Snippet string `protobuf:"bytes,3,opt,name=snippet,proto3,oneof"`
}

func (*CommandActionComplete_TestResult) isCommandActionComplete_Result() {}
func (*CommandActionComplete_Snippet) isCommandActionComplete_Result()    {}

func (m *CommandActionComplete) GetResult() isCommandActionComplete_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *CommandActionComplete) GetCompletedId() string {
	if m != nil {
		return m.CompletedId
	}
	return ""
}

func (m *CommandActionComplete) GetTestResult() *TestResult {
	if x, ok := m.GetResult().(*CommandActionComplete_TestResult); ok {
		return x.TestResult
	}
	return nil
}

func (m *CommandActionComplete) GetSnippet() string {
	if x, ok := m.GetResult().(*CommandActionComplete_Snippet); ok {
		return x.Snippet
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CommandActionComplete) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CommandActionComplete_OneofMarshaler, _CommandActionComplete_OneofUnmarshaler, _CommandActionComplete_OneofSizer, []interface{}{
		(*CommandActionComplete_TestResult)(nil),
		(*CommandActionComplete_Snippet)(nil),
	}
}

func _CommandActionComplete_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CommandActionComplete)
	// result
	switch x := m.Result.(type) {
	case *CommandActionComplete_TestResult:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestResult); err != nil {
			return err
		}
	case *CommandActionComplete_Snippet:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Snippet)
	case nil:
	default:
		return fmt.Errorf("CommandActionComplete.Result has unexpected type %T", x)
	}
	return nil
}

func _CommandActionComplete_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CommandActionComplete)
	switch tag {
	case 2: // result.testResult
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestResult)
		err := b.DecodeMessage(msg)
		m.Result = &CommandActionComplete_TestResult{msg}
		return true, err
	case 3: // result.snippet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Result = &CommandActionComplete_Snippet{x}
		return true, err
	default:
		return false, nil
	}
}

func _CommandActionComplete_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CommandActionComplete)
	// result
	switch x := m.Result.(type) {
	case *CommandActionComplete_TestResult:
		s := proto.Size(x.TestResult)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommandActionComplete_Snippet:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Snippet)))
		n += len(x.Snippet)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CommandRunBeforeTestRunHooks struct {
	ActionId string `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
}

func (m *CommandRunBeforeTestRunHooks) Reset()         { *m = CommandRunBeforeTestRunHooks{} }
func (m *CommandRunBeforeTestRunHooks) String() string { return proto.CompactTextString(m) }
func (*CommandRunBeforeTestRunHooks) ProtoMessage()    {}
func (*CommandRunBeforeTestRunHooks) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{34}
}

func (m *CommandRunBeforeTestRunHooks) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

type CommandRunAfterTestRunHooks struct {
	ActionId string `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
}

func (m *CommandRunAfterTestRunHooks) Reset()         { *m = CommandRunAfterTestRunHooks{} }
func (m *CommandRunAfterTestRunHooks) String() string { return proto.CompactTextString(m) }
func (*CommandRunAfterTestRunHooks) ProtoMessage()    {}
func (*CommandRunAfterTestRunHooks) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{35}
}

func (m *CommandRunAfterTestRunHooks) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

type CommandInitializeTestCase struct {
	ActionId string  `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
	Pickle   *Pickle `protobuf:"bytes,3,opt,name=pickle" json:"pickle,omitempty"`
}

func (m *CommandInitializeTestCase) Reset()         { *m = CommandInitializeTestCase{} }
func (m *CommandInitializeTestCase) String() string { return proto.CompactTextString(m) }
func (*CommandInitializeTestCase) ProtoMessage()    {}
func (*CommandInitializeTestCase) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{36}
}

func (m *CommandInitializeTestCase) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

func (m *CommandInitializeTestCase) GetPickle() *Pickle {
	if m != nil {
		return m.Pickle
	}
	return nil
}

type CommandRunBeforeTestCaseHook struct {
	ActionId                 string `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
	TestCaseHookDefinitionId string `protobuf:"bytes,3,opt,name=testCaseHookDefinitionId,proto3" json:"testCaseHookDefinitionId,omitempty"`
	PickleId                 string `protobuf:"bytes,4,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
}

func (m *CommandRunBeforeTestCaseHook) Reset()         { *m = CommandRunBeforeTestCaseHook{} }
func (m *CommandRunBeforeTestCaseHook) String() string { return proto.CompactTextString(m) }
func (*CommandRunBeforeTestCaseHook) ProtoMessage()    {}
func (*CommandRunBeforeTestCaseHook) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{37}
}

func (m *CommandRunBeforeTestCaseHook) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

func (m *CommandRunBeforeTestCaseHook) GetTestCaseHookDefinitionId() string {
	if m != nil {
		return m.TestCaseHookDefinitionId
	}
	return ""
}

func (m *CommandRunBeforeTestCaseHook) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

type CommandRunAfterTestCaseHook struct {
	ActionId                 string `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
	TestCaseHookDefinitionId string `protobuf:"bytes,3,opt,name=testCaseHookDefinitionId,proto3" json:"testCaseHookDefinitionId,omitempty"`
	PickleId                 string `protobuf:"bytes,4,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
}

func (m *CommandRunAfterTestCaseHook) Reset()         { *m = CommandRunAfterTestCaseHook{} }
func (m *CommandRunAfterTestCaseHook) String() string { return proto.CompactTextString(m) }
func (*CommandRunAfterTestCaseHook) ProtoMessage()    {}
func (*CommandRunAfterTestCaseHook) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{38}
}

func (m *CommandRunAfterTestCaseHook) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

func (m *CommandRunAfterTestCaseHook) GetTestCaseHookDefinitionId() string {
	if m != nil {
		return m.TestCaseHookDefinitionId
	}
	return ""
}

func (m *CommandRunAfterTestCaseHook) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

type CommandRunTestStep struct {
	ActionId           string              `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
	StepDefinitionId   string              `protobuf:"bytes,3,opt,name=stepDefinitionId,proto3" json:"stepDefinitionId,omitempty"`
	PatternMatches     []*PatternMatch     `protobuf:"bytes,4,rep,name=patternMatches" json:"patternMatches,omitempty"`
	PickleId           string              `protobuf:"bytes,5,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
	PickleStepArgument *PickleStepArgument `protobuf:"bytes,6,opt,name=pickleStepArgument" json:"pickleStepArgument,omitempty"`
}

func (m *CommandRunTestStep) Reset()                    { *m = CommandRunTestStep{} }
func (m *CommandRunTestStep) String() string            { return proto.CompactTextString(m) }
func (*CommandRunTestStep) ProtoMessage()               {}
func (*CommandRunTestStep) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{39} }

func (m *CommandRunTestStep) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

func (m *CommandRunTestStep) GetStepDefinitionId() string {
	if m != nil {
		return m.StepDefinitionId
	}
	return ""
}

func (m *CommandRunTestStep) GetPatternMatches() []*PatternMatch {
	if m != nil {
		return m.PatternMatches
	}
	return nil
}

func (m *CommandRunTestStep) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

func (m *CommandRunTestStep) GetPickleStepArgument() *PickleStepArgument {
	if m != nil {
		return m.PickleStepArgument
	}
	return nil
}

type PatternMatch struct {
	Captures          []string `protobuf:"bytes,1,rep,name=captures" json:"captures,omitempty"`
	ParameterTypeName string   `protobuf:"bytes,2,opt,name=parameterTypeName,proto3" json:"parameterTypeName,omitempty"`
}

func (m *PatternMatch) Reset()                    { *m = PatternMatch{} }
func (m *PatternMatch) String() string            { return proto.CompactTextString(m) }
func (*PatternMatch) ProtoMessage()               {}
func (*PatternMatch) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{40} }

func (m *PatternMatch) GetCaptures() []string {
	if m != nil {
		return m.Captures
	}
	return nil
}

func (m *PatternMatch) GetParameterTypeName() string {
	if m != nil {
		return m.ParameterTypeName
	}
	return ""
}

type CommandGenerateSnippet struct {
	ActionId             string                 `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
	GeneratedExpressions []*GeneratedExpression `protobuf:"bytes,2,rep,name=generatedExpressions" json:"generatedExpressions,omitempty"`
	PickleStepArgument   *PickleStepArgument    `protobuf:"bytes,5,opt,name=pickleStepArgument" json:"pickleStepArgument,omitempty"`
}

func (m *CommandGenerateSnippet) Reset()                    { *m = CommandGenerateSnippet{} }
func (m *CommandGenerateSnippet) String() string            { return proto.CompactTextString(m) }
func (*CommandGenerateSnippet) ProtoMessage()               {}
func (*CommandGenerateSnippet) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{41} }

func (m *CommandGenerateSnippet) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

func (m *CommandGenerateSnippet) GetGeneratedExpressions() []*GeneratedExpression {
	if m != nil {
		return m.GeneratedExpressions
	}
	return nil
}

func (m *CommandGenerateSnippet) GetPickleStepArgument() *PickleStepArgument {
	if m != nil {
		return m.PickleStepArgument
	}
	return nil
}

type GeneratedExpression struct {
	Text               string   `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	ParameterTypeNames []string `protobuf:"bytes,2,rep,name=parameterTypeNames" json:"parameterTypeNames,omitempty"`
}

func (m *GeneratedExpression) Reset()                    { *m = GeneratedExpression{} }
func (m *GeneratedExpression) String() string            { return proto.CompactTextString(m) }
func (*GeneratedExpression) ProtoMessage()               {}
func (*GeneratedExpression) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{42} }

func (m *GeneratedExpression) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *GeneratedExpression) GetParameterTypeNames() []string {
	if m != nil {
		return m.ParameterTypeNames
	}
	return nil
}

func init() {
	proto.RegisterType((*Envelope)(nil), "io.cucumber.messages.Envelope")
	proto.RegisterType((*Location)(nil), "io.cucumber.messages.Location")
	proto.RegisterType((*SourceReference)(nil), "io.cucumber.messages.SourceReference")
	proto.RegisterType((*Media)(nil), "io.cucumber.messages.Media")
	proto.RegisterType((*Source)(nil), "io.cucumber.messages.Source")
	proto.RegisterType((*GherkinDocument)(nil), "io.cucumber.messages.GherkinDocument")
	proto.RegisterType((*GherkinDocument_Comment)(nil), "io.cucumber.messages.GherkinDocument.Comment")
	proto.RegisterType((*GherkinDocument_Feature)(nil), "io.cucumber.messages.GherkinDocument.Feature")
	proto.RegisterType((*GherkinDocument_Feature_Tag)(nil), "io.cucumber.messages.GherkinDocument.Feature.Tag")
	proto.RegisterType((*GherkinDocument_Feature_FeatureChild)(nil), "io.cucumber.messages.GherkinDocument.Feature.FeatureChild")
	proto.RegisterType((*GherkinDocument_Feature_FeatureChild_Rule)(nil), "io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule")
	proto.RegisterType((*GherkinDocument_Feature_FeatureChild_RuleChild)(nil), "io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild")
	proto.RegisterType((*GherkinDocument_Feature_Background)(nil), "io.cucumber.messages.GherkinDocument.Feature.Background")
	proto.RegisterType((*GherkinDocument_Feature_Scenario)(nil), "io.cucumber.messages.GherkinDocument.Feature.Scenario")
	proto.RegisterType((*GherkinDocument_Feature_Scenario_Examples)(nil), "io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples")
	proto.RegisterType((*GherkinDocument_Feature_TableRow)(nil), "io.cucumber.messages.GherkinDocument.Feature.TableRow")
	proto.RegisterType((*GherkinDocument_Feature_TableRow_TableCell)(nil), "io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell")
	proto.RegisterType((*GherkinDocument_Feature_Step)(nil), "io.cucumber.messages.GherkinDocument.Feature.Step")
	proto.RegisterType((*GherkinDocument_Feature_Step_DataTable)(nil), "io.cucumber.messages.GherkinDocument.Feature.Step.DataTable")
	proto.RegisterType((*GherkinDocument_Feature_Step_DocString)(nil), "io.cucumber.messages.GherkinDocument.Feature.Step.DocString")
	proto.RegisterType((*Attachment)(nil), "io.cucumber.messages.Attachment")
	proto.RegisterType((*Pickle)(nil), "io.cucumber.messages.Pickle")
	proto.RegisterType((*Pickle_PickleTag)(nil), "io.cucumber.messages.Pickle.PickleTag")
	proto.RegisterType((*Pickle_PickleStep)(nil), "io.cucumber.messages.Pickle.PickleStep")
	proto.RegisterType((*PickleStepArgument)(nil), "io.cucumber.messages.PickleStepArgument")
	proto.RegisterType((*PickleStepArgument_PickleDocString)(nil), "io.cucumber.messages.PickleStepArgument.PickleDocString")
	proto.RegisterType((*PickleStepArgument_PickleTable)(nil), "io.cucumber.messages.PickleStepArgument.PickleTable")
	proto.RegisterType((*PickleStepArgument_PickleTable_PickleTableRow)(nil), "io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow")
	proto.RegisterType((*PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell)(nil), "io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell")
	proto.RegisterType((*PickleAccepted)(nil), "io.cucumber.messages.PickleAccepted")
	proto.RegisterType((*PickleRejected)(nil), "io.cucumber.messages.PickleRejected")
	proto.RegisterType((*TestRunStarted)(nil), "io.cucumber.messages.TestRunStarted")
	proto.RegisterType((*TestCasePreparedStep)(nil), "io.cucumber.messages.TestCasePreparedStep")
	proto.RegisterType((*TestCasePrepared)(nil), "io.cucumber.messages.TestCasePrepared")
	proto.RegisterType((*TestCaseStarted)(nil), "io.cucumber.messages.TestCaseStarted")
	proto.RegisterType((*TestCaseStarted_Platform)(nil), "io.cucumber.messages.TestCaseStarted.Platform")
	proto.RegisterType((*TestCaseFinished)(nil), "io.cucumber.messages.TestCaseFinished")
	proto.RegisterType((*TestStepStarted)(nil), "io.cucumber.messages.TestStepStarted")
	proto.RegisterType((*TestStepFinished)(nil), "io.cucumber.messages.TestStepFinished")
	proto.RegisterType((*TestHookStarted)(nil), "io.cucumber.messages.TestHookStarted")
	proto.RegisterType((*TestHookFinished)(nil), "io.cucumber.messages.TestHookFinished")
	proto.RegisterType((*TestResult)(nil), "io.cucumber.messages.TestResult")
	proto.RegisterType((*TestRunFinished)(nil), "io.cucumber.messages.TestRunFinished")
	proto.RegisterType((*CommandStart)(nil), "io.cucumber.messages.CommandStart")
	proto.RegisterType((*SourcesConfig)(nil), "io.cucumber.messages.SourcesConfig")
	proto.RegisterType((*SourcesFilterConfig)(nil), "io.cucumber.messages.SourcesFilterConfig")
	proto.RegisterType((*UriToLinesMapping)(nil), "io.cucumber.messages.UriToLinesMapping")
	proto.RegisterType((*SourcesOrder)(nil), "io.cucumber.messages.SourcesOrder")
	proto.RegisterType((*RuntimeConfig)(nil), "io.cucumber.messages.RuntimeConfig")
	proto.RegisterType((*SupportCodeConfig)(nil), "io.cucumber.messages.SupportCodeConfig")
	proto.RegisterType((*TestCaseHookDefinitionConfig)(nil), "io.cucumber.messages.TestCaseHookDefinitionConfig")
	proto.RegisterType((*StepDefinitionConfig)(nil), "io.cucumber.messages.StepDefinitionConfig")
	proto.RegisterType((*StepDefinitionPattern)(nil), "io.cucumber.messages.StepDefinitionPattern")
	proto.RegisterType((*ParameterTypeConfig)(nil), "io.cucumber.messages.ParameterTypeConfig")
	proto.RegisterType((*CommandActionComplete)(nil), "io.cucumber.messages.CommandActionComplete")
	proto.RegisterType((*CommandRunBeforeTestRunHooks)(nil), "io.cucumber.messages.CommandRunBeforeTestRunHooks")
	proto.RegisterType((*CommandRunAfterTestRunHooks)(nil), "io.cucumber.messages.CommandRunAfterTestRunHooks")
	proto.RegisterType((*CommandInitializeTestCase)(nil), "io.cucumber.messages.CommandInitializeTestCase")
	proto.RegisterType((*CommandRunBeforeTestCaseHook)(nil), "io.cucumber.messages.CommandRunBeforeTestCaseHook")
	proto.RegisterType((*CommandRunAfterTestCaseHook)(nil), "io.cucumber.messages.CommandRunAfterTestCaseHook")
	proto.RegisterType((*CommandRunTestStep)(nil), "io.cucumber.messages.CommandRunTestStep")
	proto.RegisterType((*PatternMatch)(nil), "io.cucumber.messages.PatternMatch")
	proto.RegisterType((*CommandGenerateSnippet)(nil), "io.cucumber.messages.CommandGenerateSnippet")
	proto.RegisterType((*GeneratedExpression)(nil), "io.cucumber.messages.GeneratedExpression")
	proto.RegisterEnum("io.cucumber.messages.SourcesOrderType", SourcesOrderType_name, SourcesOrderType_value)
	proto.RegisterEnum("io.cucumber.messages.StepDefinitionPatternType", StepDefinitionPatternType_name, StepDefinitionPatternType_value)
	proto.RegisterEnum("io.cucumber.messages.Media_Encoding", Media_Encoding_name, Media_Encoding_value)
	proto.RegisterEnum("io.cucumber.messages.TestResult_Status", TestResult_Status_name, TestResult_Status_value)
}
func (m *Envelope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Envelope) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		nn1, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *Envelope_Source) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Source != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Source.Size()))
		n2, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *Envelope_GherkinDocument) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GherkinDocument != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.GherkinDocument.Size()))
		n3, err := m.GherkinDocument.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *Envelope_Pickle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Pickle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Pickle.Size()))
		n4, err := m.Pickle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *Envelope_Attachment) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Attachment != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Attachment.Size()))
		n5, err := m.Attachment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *Envelope_TestCaseStarted) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestCaseStarted != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestCaseStarted.Size()))
		n6, err := m.TestCaseStarted.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *Envelope_TestStepStarted) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestStepStarted != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestStepStarted.Size()))
		n7, err := m.TestStepStarted.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *Envelope_TestStepFinished) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestStepFinished != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestStepFinished.Size()))
		n8, err := m.TestStepFinished.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *Envelope_TestCaseFinished) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestCaseFinished != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestCaseFinished.Size()))
		n9, err := m.TestCaseFinished.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *Envelope_TestHookStarted) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestHookStarted != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestHookStarted.Size()))
		n10, err := m.TestHookStarted.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *Envelope_TestHookFinished) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestHookFinished != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestHookFinished.Size()))
		n11, err := m.TestHookFinished.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *Envelope_PickleAccepted) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PickleAccepted != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.PickleAccepted.Size()))
		n12, err := m.PickleAccepted.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *Envelope_PickleRejected) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PickleRejected != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.PickleRejected.Size()))
		n13, err := m.PickleRejected.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *Envelope_TestCasePrepared) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestCasePrepared != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestCasePrepared.Size()))
		n14, err := m.TestCasePrepared.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *Envelope_TestRunStarted) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestRunStarted != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestRunStarted.Size()))
		n15, err := m.TestRunStarted.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *Envelope_TestRunFinished) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestRunFinished != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestRunFinished.Size()))
		n16, err := m.TestRunFinished.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *Envelope_CommandStart) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandStart != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CommandStart.Size()))
		n17, err := m.CommandStart.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *Envelope_CommandActionComplete) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandActionComplete != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CommandActionComplete.Size()))
		n18, err := m.CommandActionComplete.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *Envelope_CommandRunBeforeTestRunHooks) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandRunBeforeTestRunHooks != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CommandRunBeforeTestRunHooks.Size()))
		n19, err := m.CommandRunBeforeTestRunHooks.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *Envelope_CommandInitializeTestCase) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandInitializeTestCase != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CommandInitializeTestCase.Size()))
		n20, err := m.CommandInitializeTestCase.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}
func (m *Envelope_CommandRunBeforeTestCaseHook) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandRunBeforeTestCaseHook != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CommandRunBeforeTestCaseHook.Size()))
		n21, err := m.CommandRunBeforeTestCaseHook.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *Envelope_CommandRunTestStep) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandRunTestStep != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CommandRunTestStep.Size()))
		n22, err := m.CommandRunTestStep.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *Envelope_CommandRunAfterTestCaseHook) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandRunAfterTestCaseHook != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CommandRunAfterTestCaseHook.Size()))
		n23, err := m.CommandRunAfterTestCaseHook.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *Envelope_CommandRunAfterTestRunHooks) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandRunAfterTestRunHooks != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CommandRunAfterTestRunHooks.Size()))
		n24, err := m.CommandRunAfterTestRunHooks.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *Envelope_CommandGenerateSnippet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandGenerateSnippet != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CommandGenerateSnippet.Size()))
		n25, err := m.CommandGenerateSnippet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *Envelope_CommandError) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xca
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMessages(dAtA, i, uint64(len(m.CommandError)))
	i += copy(dAtA[i:], m.CommandError)
	return i, nil
}
func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Line != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Line))
	}
	if m.Column != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Column))
	}
	return i, nil
}

func (m *SourceReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceReference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uri) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	if m.Location != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n26, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *Media) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Media) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Encoding != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Encoding))
	}
	if len(m.ContentType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ContentType)))
		i += copy(dAtA[i:], m.ContentType)
	}
	return i, nil
}

func (m *Source) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Source) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uri) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Media != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Media.Size()))
		n27, err := m.Media.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *GherkinDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uri) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	if m.Feature != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Feature.Size()))
		n28, err := m.Feature.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if len(m.Comments) > 0 {
		for _, msg := range m.Comments {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GherkinDocument_Comment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Comment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n29, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	return i, nil
}

func (m *GherkinDocument_Feature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n30, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Language) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Children) > 0 {
		for _, msg := range m.Children {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GherkinDocument_Feature_Tag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Tag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n31, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *GherkinDocument_Feature_FeatureChild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_FeatureChild) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn32, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn32
	}
	return i, nil
}

func (m *GherkinDocument_Feature_FeatureChild_Rule_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Rule != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Rule.Size()))
		n33, err := m.Rule.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}
func (m *GherkinDocument_Feature_FeatureChild_Background) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Background != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Background.Size()))
		n34, err := m.Background.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}
func (m *GherkinDocument_Feature_FeatureChild_Scenario) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Scenario != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Scenario.Size()))
		n35, err := m.Scenario.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n36, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Children) > 0 {
		for _, msg := range m.Children {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn37, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn37
	}
	return i, nil
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild_Background) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Background != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Background.Size()))
		n38, err := m.Background.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild_Scenario) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Scenario != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Scenario.Size()))
		n39, err := m.Scenario.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}
func (m *GherkinDocument_Feature_Background) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Background) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n40, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Steps) > 0 {
		for _, msg := range m.Steps {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GherkinDocument_Feature_Scenario) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Scenario) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n41, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Steps) > 0 {
		for _, msg := range m.Steps {
			dAtA[i] = 0x32
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Examples) > 0 {
		for _, msg := range m.Examples {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GherkinDocument_Feature_Scenario_Examples) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Scenario_Examples) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n42, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.TableHeader != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TableHeader.Size()))
		n43, err := m.TableHeader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if len(m.TableBody) > 0 {
		for _, msg := range m.TableBody {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GherkinDocument_Feature_TableRow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_TableRow) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n44, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if len(m.Cells) > 0 {
		for _, msg := range m.Cells {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GherkinDocument_Feature_TableRow_TableCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_TableRow_TableCell) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n45, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *GherkinDocument_Feature_Step) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Step) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n46, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.Argument != nil {
		nn47, err := m.Argument.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn47
	}
	return i, nil
}

func (m *GherkinDocument_Feature_Step_DocString_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DocString != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.DocString.Size()))
		n48, err := m.DocString.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	return i, nil
}
func (m *GherkinDocument_Feature_Step_DataTable_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DataTable != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.DataTable.Size()))
		n49, err := m.DataTable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	return i, nil
}
func (m *GherkinDocument_Feature_Step_DataTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Step_DataTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n50, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if len(m.Rows) > 0 {
		for _, msg := range m.Rows {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GherkinDocument_Feature_Step_DocString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Step_DocString) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n51, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if len(m.ContentType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ContentType)))
		i += copy(dAtA[i:], m.ContentType)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if len(m.Delimiter) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Delimiter)))
		i += copy(dAtA[i:], m.Delimiter)
	}
	return i, nil
}

func (m *Attachment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Attachment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Source != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Source.Size()))
		n52, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Media != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Media.Size()))
		n53, err := m.Media.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	return i, nil
}

func (m *Pickle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pickle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Uri) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Language) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	if len(m.Steps) > 0 {
		for _, msg := range m.Steps {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x32
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Locations) > 0 {
		for _, msg := range m.Locations {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Pickle_PickleTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pickle_PickleTag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n54, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *Pickle_PickleStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pickle_PickleStep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if len(m.Locations) > 0 {
		for _, msg := range m.Locations {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Argument != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Argument.Size()))
		n55, err := m.Argument.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	return i, nil
}

func (m *PickleStepArgument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleStepArgument) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		nn56, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn56
	}
	return i, nil
}

func (m *PickleStepArgument_DocString) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DocString != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.DocString.Size()))
		n57, err := m.DocString.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	return i, nil
}
func (m *PickleStepArgument_DataTable) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DataTable != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.DataTable.Size()))
		n58, err := m.DataTable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	return i, nil
}
func (m *PickleStepArgument_PickleDocString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleStepArgument_PickleDocString) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n59, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if len(m.ContentType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ContentType)))
		i += copy(dAtA[i:], m.ContentType)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	return i, nil
}

func (m *PickleStepArgument_PickleTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleStepArgument_PickleTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for _, msg := range m.Rows {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PickleStepArgument_PickleTable_PickleTableRow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleStepArgument_PickleTable_PickleTableRow) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cells) > 0 {
		for _, msg := range m.Cells {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n60, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *PickleAccepted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleAccepted) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PickleId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	return i, nil
}

func (m *PickleRejected) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleRejected) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PickleId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	return i, nil
}

func (m *TestRunStarted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestRunStarted) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Timestamp.Size()))
		n61, err := m.Timestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	return i, nil
}

func (m *TestCasePreparedStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCasePreparedStep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SourceLocation != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.SourceLocation.Size()))
		n62, err := m.SourceLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	if m.ActionLocation != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.ActionLocation.Size()))
		n63, err := m.ActionLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	return i, nil
}

func (m *TestCasePrepared) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCasePrepared) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PickleId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	if len(m.Steps) > 0 {
		for _, msg := range m.Steps {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TestCaseStarted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCaseStarted) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PickleId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	if m.Timestamp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Timestamp.Size()))
		n64, err := m.Timestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if m.Platform != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Platform.Size()))
		n65, err := m.Platform.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	return i, nil
}

func (m *TestCaseStarted_Platform) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCaseStarted_Platform) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Implementation) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Implementation)))
		i += copy(dAtA[i:], m.Implementation)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Os) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Os)))
		i += copy(dAtA[i:], m.Os)
	}
	if len(m.Cpu) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Cpu)))
		i += copy(dAtA[i:], m.Cpu)
	}
	return i, nil
}

func (m *TestCaseFinished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCaseFinished) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PickleId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	if m.Timestamp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Timestamp.Size()))
		n66, err := m.Timestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if m.TestResult != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestResult.Size()))
		n67, err := m.TestResult.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	return i, nil
}

func (m *TestStepStarted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestStepStarted) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PickleId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	if m.Index != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Index))
	}
	if m.Timestamp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Timestamp.Size()))
		n68, err := m.Timestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	return i, nil
}

func (m *TestStepFinished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestStepFinished) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PickleId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	if m.Index != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Index))
	}
	if m.TestResult != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestResult.Size()))
		n69, err := m.TestResult.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	if m.Timestamp != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Timestamp.Size()))
		n70, err := m.Timestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	return i, nil
}

func (m *TestHookStarted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestHookStarted) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PickleId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	if m.Timestamp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Timestamp.Size()))
		n71, err := m.Timestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	return i, nil
}

func (m *TestHookFinished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestHookFinished) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PickleId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	if m.TestResult != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestResult.Size()))
		n72, err := m.TestResult.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	if m.Timestamp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Timestamp.Size()))
		n73, err := m.Timestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	return i, nil
}

func (m *TestResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Status))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.DurationNanoseconds != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.DurationNanoseconds))
	}
	return i, nil
}

func (m *TestRunFinished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestRunFinished) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CommandStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandStart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BaseDirectory) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.BaseDirectory)))
		i += copy(dAtA[i:], m.BaseDirectory)
	}
	if m.SourcesConfig != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.SourcesConfig.Size()))
		n74, err := m.SourcesConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if m.RuntimeConfig != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.RuntimeConfig.Size()))
		n75, err := m.RuntimeConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	if m.SupportCodeConfig != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.SupportCodeConfig.Size()))
		n76, err := m.SupportCodeConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	return i, nil
}

func (m *SourcesConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourcesConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AbsolutePaths) > 0 {
		for _, s := range m.AbsolutePaths {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Language) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	if m.Filters != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Filters.Size()))
		n77, err := m.Filters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n77
	}
	if m.Order != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Order.Size()))
		n78, err := m.Order.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	return i, nil
}

func (m *SourcesFilterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourcesFilterConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TagExpression) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TagExpression)))
		i += copy(dAtA[i:], m.TagExpression)
	}
	if len(m.NameRegularExpressions) > 0 {
		for _, s := range m.NameRegularExpressions {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.UriToLinesMapping) > 0 {
		for _, msg := range m.UriToLinesMapping {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UriToLinesMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UriToLinesMapping) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AbsolutePath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.AbsolutePath)))
		i += copy(dAtA[i:], m.AbsolutePath)
	}
	if len(m.Lines) > 0 {
		dAtA80 := make([]byte, len(m.Lines)*10)
		var j79 int
		for _, num := range m.Lines {
			for num >= 1<<7 {
				dAtA80[j79] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j79++
			}
			dAtA80[j79] = uint8(num)
			j79++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(j79))
		i += copy(dAtA[i:], dAtA80[:j79])
	}
	return i, nil
}

func (m *SourcesOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourcesOrder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Type))
	}
	if m.Seed != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Seed))
	}
	return i, nil
}

func (m *RuntimeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuntimeConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsFailFast {
		dAtA[i] = 0x8
		i++
		if m.IsFailFast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsDryRun {
		dAtA[i] = 0x10
		i++
		if m.IsDryRun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsStrict {
		dAtA[i] = 0x18
		i++
		if m.IsStrict {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxParallel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.MaxParallel))
	}
	return i, nil
}

func (m *SupportCodeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupportCodeConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BeforeTestCaseHookDefinitionConfigs) > 0 {
		for _, msg := range m.BeforeTestCaseHookDefinitionConfigs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AfterTestCaseHookDefinitionConfigs) > 0 {
		for _, msg := range m.AfterTestCaseHookDefinitionConfigs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.StepDefinitionConfigs) > 0 {
		for _, msg := range m.StepDefinitionConfigs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ParameterTypeConfigs) > 0 {
		for _, msg := range m.ParameterTypeConfigs {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TestCaseHookDefinitionConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCaseHookDefinitionConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.TagExpression) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TagExpression)))
		i += copy(dAtA[i:], m.TagExpression)
	}
	if m.Location != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n81, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	return i, nil
}

func (m *StepDefinitionConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepDefinitionConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Pattern != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Pattern.Size()))
		n82, err := m.Pattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n82
	}
	if m.Location != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n83, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	return i, nil
}

func (m *StepDefinitionPattern) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepDefinitionPattern) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *ParameterTypeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParameterTypeConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.RegularExpressions) > 0 {
		for _, s := range m.RegularExpressions {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.PreferForRegularExpressionMatch {
		dAtA[i] = 0x18
		i++
		if m.PreferForRegularExpressionMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UseForSnippets {
		dAtA[i] = 0x20
		i++
		if m.UseForSnippets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CommandActionComplete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandActionComplete) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CompletedId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.CompletedId)))
		i += copy(dAtA[i:], m.CompletedId)
	}
	if m.Result != nil {
		nn84, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn84
	}
	return i, nil
}

func (m *CommandActionComplete_TestResult) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestResult != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestResult.Size()))
		n85, err := m.TestResult.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n85
	}
	return i, nil
}
func (m *CommandActionComplete_Snippet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMessages(dAtA, i, uint64(len(m.Snippet)))
	i += copy(dAtA[i:], m.Snippet)
	return i, nil
}
func (m *CommandRunBeforeTestRunHooks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRunBeforeTestRunHooks) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ActionId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i += copy(dAtA[i:], m.ActionId)
	}
	return i, nil
}

func (m *CommandRunAfterTestRunHooks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRunAfterTestRunHooks) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ActionId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i += copy(dAtA[i:], m.ActionId)
	}
	return i, nil
}

func (m *CommandInitializeTestCase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandInitializeTestCase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ActionId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i += copy(dAtA[i:], m.ActionId)
	}
	if m.Pickle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Pickle.Size()))
		n86, err := m.Pickle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n86
	}
	return i, nil
}

func (m *CommandRunBeforeTestCaseHook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRunBeforeTestCaseHook) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ActionId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i += copy(dAtA[i:], m.ActionId)
	}
	if len(m.TestCaseHookDefinitionId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseHookDefinitionId)))
		i += copy(dAtA[i:], m.TestCaseHookDefinitionId)
	}
	if len(m.PickleId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	return i, nil
}

func (m *CommandRunAfterTestCaseHook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRunAfterTestCaseHook) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ActionId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i += copy(dAtA[i:], m.ActionId)
	}
	if len(m.TestCaseHookDefinitionId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseHookDefinitionId)))
		i += copy(dAtA[i:], m.TestCaseHookDefinitionId)
	}
	if len(m.PickleId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	return i, nil
}

func (m *CommandRunTestStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRunTestStep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ActionId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i += copy(dAtA[i:], m.ActionId)
	}
	if len(m.StepDefinitionId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.StepDefinitionId)))
		i += copy(dAtA[i:], m.StepDefinitionId)
	}
	if len(m.PatternMatches) > 0 {
		for _, msg := range m.PatternMatches {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PickleId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	if m.PickleStepArgument != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.PickleStepArgument.Size()))
		n87, err := m.PickleStepArgument.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n87
	}
	return i, nil
}

func (m *PatternMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatternMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Captures) > 0 {
		for _, s := range m.Captures {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ParameterTypeName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ParameterTypeName)))
		i += copy(dAtA[i:], m.ParameterTypeName)
	}
	return i, nil
}

func (m *CommandGenerateSnippet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandGenerateSnippet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ActionId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i += copy(dAtA[i:], m.ActionId)
	}
	if len(m.GeneratedExpressions) > 0 {
		for _, msg := range m.GeneratedExpressions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PickleStepArgument != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.PickleStepArgument.Size()))
		n88, err := m.PickleStepArgument.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n88
	}
	return i, nil
}

func (m *GeneratedExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeneratedExpression) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if len(m.ParameterTypeNames) > 0 {
		for _, s := range m.ParameterTypeNames {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeFixed64Messages(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Messages(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMessages(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Envelope) Size() (n int) {
	var l int
	_ = l
	if m.Message != nil {
		n += m.Message.Size()
	}
	return n
}

func (m *Envelope_Source) Size() (n int) {
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_GherkinDocument) Size() (n int) {
	var l int
	_ = l
	if m.GherkinDocument != nil {
		l = m.GherkinDocument.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_Pickle) Size() (n int) {
	var l int
	_ = l
	if m.Pickle != nil {
		l = m.Pickle.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_Attachment) Size() (n int) {
	var l int
	_ = l
	if m.Attachment != nil {
		l = m.Attachment.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestCaseStarted) Size() (n int) {
	var l int
	_ = l
	if m.TestCaseStarted != nil {
		l = m.TestCaseStarted.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestStepStarted) Size() (n int) {
	var l int
	_ = l
	if m.TestStepStarted != nil {
		l = m.TestStepStarted.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestStepFinished) Size() (n int) {
	var l int
	_ = l
	if m.TestStepFinished != nil {
		l = m.TestStepFinished.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestCaseFinished) Size() (n int) {
	var l int
	_ = l
	if m.TestCaseFinished != nil {
		l = m.TestCaseFinished.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestHookStarted) Size() (n int) {
	var l int
	_ = l
	if m.TestHookStarted != nil {
		l = m.TestHookStarted.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestHookFinished) Size() (n int) {
	var l int
	_ = l
	if m.TestHookFinished != nil {
		l = m.TestHookFinished.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_PickleAccepted) Size() (n int) {
	var l int
	_ = l
	if m.PickleAccepted != nil {
		l = m.PickleAccepted.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_PickleRejected) Size() (n int) {
	var l int
	_ = l
	if m.PickleRejected != nil {
		l = m.PickleRejected.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestCasePrepared) Size() (n int) {
	var l int
	_ = l
	if m.TestCasePrepared != nil {
		l = m.TestCasePrepared.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestRunStarted) Size() (n int) {
	var l int
	_ = l
	if m.TestRunStarted != nil {
		l = m.TestRunStarted.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestRunFinished) Size() (n int) {
	var l int
	_ = l
	if m.TestRunFinished != nil {
		l = m.TestRunFinished.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_CommandStart) Size() (n int) {
	var l int
	_ = l
	if m.CommandStart != nil {
		l = m.CommandStart.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_CommandActionComplete) Size() (n int) {
	var l int
	_ = l
	if m.CommandActionComplete != nil {
		l = m.CommandActionComplete.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_CommandRunBeforeTestRunHooks) Size() (n int) {
	var l int
	_ = l
	if m.CommandRunBeforeTestRunHooks != nil {
		l = m.CommandRunBeforeTestRunHooks.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_CommandInitializeTestCase) Size() (n int) {
	var l int
	_ = l
	if m.CommandInitializeTestCase != nil {
		l = m.CommandInitializeTestCase.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_CommandRunBeforeTestCaseHook) Size() (n int) {
	var l int
	_ = l
	if m.CommandRunBeforeTestCaseHook != nil {
		l = m.CommandRunBeforeTestCaseHook.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_CommandRunTestStep) Size() (n int) {
	var l int
	_ = l
	if m.CommandRunTestStep != nil {
		l = m.CommandRunTestStep.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_CommandRunAfterTestCaseHook) Size() (n int) {
	var l int
	_ = l
	if m.CommandRunAfterTestCaseHook != nil {
		l = m.CommandRunAfterTestCaseHook.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_CommandRunAfterTestRunHooks) Size() (n int) {
	var l int
	_ = l
	if m.CommandRunAfterTestRunHooks != nil {
		l = m.CommandRunAfterTestRunHooks.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_CommandGenerateSnippet) Size() (n int) {
	var l int
	_ = l
	if m.CommandGenerateSnippet != nil {
		l = m.CommandGenerateSnippet.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_CommandError) Size() (n int) {
	var l int
	_ = l
	l = len(m.CommandError)
	n += 2 + l + sovMessages(uint64(l))
	return n
}
func (m *Location) Size() (n int) {
	var l int
	_ = l
	if m.Line != 0 {
		n += 1 + sovMessages(uint64(m.Line))
	}
	if m.Column != 0 {
		n += 1 + sovMessages(uint64(m.Column))
	}
	return n
}

func (m *SourceReference) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Media) Size() (n int) {
	var l int
	_ = l
	if m.Encoding != 0 {
		n += 1 + sovMessages(uint64(m.Encoding))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Source) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Media != nil {
		l = m.Media.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Feature != nil {
		l = m.Feature.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Comments) > 0 {
		for _, e := range m.Comments {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GherkinDocument_Comment) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument_Feature) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GherkinDocument_Feature_Tag) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument_Feature_FeatureChild) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *GherkinDocument_Feature_FeatureChild_Rule_) Size() (n int) {
	var l int
	_ = l
	if m.Rule != nil {
		l = m.Rule.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_FeatureChild_Background) Size() (n int) {
	var l int
	_ = l
	if m.Background != nil {
		l = m.Background.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_FeatureChild_Scenario) Size() (n int) {
	var l int
	_ = l
	if m.Scenario != nil {
		l = m.Scenario.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild_Background) Size() (n int) {
	var l int
	_ = l
	if m.Background != nil {
		l = m.Background.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild_Scenario) Size() (n int) {
	var l int
	_ = l
	if m.Scenario != nil {
		l = m.Scenario.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_Background) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GherkinDocument_Feature_Scenario) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.Examples) > 0 {
		for _, e := range m.Examples {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GherkinDocument_Feature_Scenario_Examples) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.TableHeader != nil {
		l = m.TableHeader.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.TableBody) > 0 {
		for _, e := range m.TableBody {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GherkinDocument_Feature_TableRow) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Cells) > 0 {
		for _, e := range m.Cells {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GherkinDocument_Feature_TableRow_TableCell) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument_Feature_Step) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Argument != nil {
		n += m.Argument.Size()
	}
	return n
}

func (m *GherkinDocument_Feature_Step_DocString_) Size() (n int) {
	var l int
	_ = l
	if m.DocString != nil {
		l = m.DocString.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_Step_DataTable_) Size() (n int) {
	var l int
	_ = l
	if m.DataTable != nil {
		l = m.DataTable.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_Step_DataTable) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GherkinDocument_Feature_Step_DocString) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Delimiter)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Attachment) Size() (n int) {
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Media != nil {
		l = m.Media.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Pickle) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.Locations) > 0 {
		for _, e := range m.Locations {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *Pickle_PickleTag) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Pickle_PickleStep) Size() (n int) {
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Locations) > 0 {
		for _, e := range m.Locations {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.Argument != nil {
		l = m.Argument.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *PickleStepArgument) Size() (n int) {
	var l int
	_ = l
	if m.Message != nil {
		n += m.Message.Size()
	}
	return n
}

func (m *PickleStepArgument_DocString) Size() (n int) {
	var l int
	_ = l
	if m.DocString != nil {
		l = m.DocString.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *PickleStepArgument_DataTable) Size() (n int) {
	var l int
	_ = l
	if m.DataTable != nil {
		l = m.DataTable.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *PickleStepArgument_PickleDocString) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *PickleStepArgument_PickleTable) Size() (n int) {
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *PickleStepArgument_PickleTable_PickleTableRow) Size() (n int) {
	var l int
	_ = l
	if len(m.Cells) > 0 {
		for _, e := range m.Cells {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *PickleAccepted) Size() (n int) {
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *PickleRejected) Size() (n int) {
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestRunStarted) Size() (n int) {
	var l int
	_ = l
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestCasePreparedStep) Size() (n int) {
	var l int
	_ = l
	if m.SourceLocation != nil {
		l = m.SourceLocation.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.ActionLocation != nil {
		l = m.ActionLocation.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestCasePrepared) Size() (n int) {
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *TestCaseStarted) Size() (n int) {
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Platform != nil {
		l = m.Platform.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestCaseStarted_Platform) Size() (n int) {
	var l int
	_ = l
	l = len(m.Implementation)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Os)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Cpu)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestCaseFinished) Size() (n int) {
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.TestResult != nil {
		l = m.TestResult.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestStepStarted) Size() (n int) {
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovMessages(uint64(m.Index))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestStepFinished) Size() (n int) {
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovMessages(uint64(m.Index))
	}
	if m.TestResult != nil {
		l = m.TestResult.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestHookStarted) Size() (n int) {
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestHookFinished) Size() (n int) {
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.TestResult != nil {
		l = m.TestResult.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestResult) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovMessages(uint64(m.Status))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.DurationNanoseconds != 0 {
		n += 1 + sovMessages(uint64(m.DurationNanoseconds))
	}
	return n
}

func (m *TestRunFinished) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *CommandStart) Size() (n int) {
	var l int
	_ = l
	l = len(m.BaseDirectory)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.SourcesConfig != nil {
		l = m.SourcesConfig.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.RuntimeConfig != nil {
		l = m.RuntimeConfig.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.SupportCodeConfig != nil {
		l = m.SupportCodeConfig.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *SourcesConfig) Size() (n int) {
	var l int
	_ = l
	if len(m.AbsolutePaths) > 0 {
		for _, s := range m.AbsolutePaths {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Filters != nil {
		l = m.Filters.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *SourcesFilterConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.TagExpression)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.NameRegularExpressions) > 0 {
		for _, s := range m.NameRegularExpressions {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.UriToLinesMapping) > 0 {
		for _, e := range m.UriToLinesMapping {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *UriToLinesMapping) Size() (n int) {
	var l int
	_ = l
	l = len(m.AbsolutePath)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Lines) > 0 {
		l = 0
		for _, e := range m.Lines {
			l += sovMessages(uint64(e))
		}
		n += 1 + sovMessages(uint64(l)) + l
	}
	return n
}

func (m *SourcesOrder) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMessages(uint64(m.Type))
	}
	if m.Seed != 0 {
		n += 1 + sovMessages(uint64(m.Seed))
	}
	return n
}

func (m *RuntimeConfig) Size() (n int) {
	var l int
	_ = l
	if m.IsFailFast {
		n += 2
	}
	if m.IsDryRun {
		n += 2
	}
	if m.IsStrict {
		n += 2
	}
	if m.MaxParallel != 0 {
		n += 1 + sovMessages(uint64(m.MaxParallel))
	}
	return n
}

func (m *SupportCodeConfig) Size() (n int) {
	var l int
	_ = l
	if len(m.BeforeTestCaseHookDefinitionConfigs) > 0 {
		for _, e := range m.BeforeTestCaseHookDefinitionConfigs {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.AfterTestCaseHookDefinitionConfigs) > 0 {
		for _, e := range m.AfterTestCaseHookDefinitionConfigs {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.StepDefinitionConfigs) > 0 {
		for _, e := range m.StepDefinitionConfigs {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.ParameterTypeConfigs) > 0 {
		for _, e := range m.ParameterTypeConfigs {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *TestCaseHookDefinitionConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TagExpression)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *StepDefinitionConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *StepDefinitionPattern) Size() (n int) {
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovMessages(uint64(m.Type))
	}
	return n
}

func (m *ParameterTypeConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.RegularExpressions) > 0 {
		for _, s := range m.RegularExpressions {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.PreferForRegularExpressionMatch {
		n += 2
	}
	if m.UseForSnippets {
		n += 2
	}
	return n
}

func (m *CommandActionComplete) Size() (n int) {
	var l int
	_ = l
	l = len(m.CompletedId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Result != nil {
		n += m.Result.Size()
	}
	return n
}

func (m *CommandActionComplete_TestResult) Size() (n int) {
	var l int
	_ = l
	if m.TestResult != nil {
		l = m.TestResult.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *CommandActionComplete_Snippet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Snippet)
	n += 1 + l + sovMessages(uint64(l))
	return n
}
func (m *CommandRunBeforeTestRunHooks) Size() (n int) {
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *CommandRunAfterTestRunHooks) Size() (n int) {
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *CommandInitializeTestCase) Size() (n int) {
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Pickle != nil {
		l = m.Pickle.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *CommandRunBeforeTestCaseHook) Size() (n int) {
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseHookDefinitionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *CommandRunAfterTestCaseHook) Size() (n int) {
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseHookDefinitionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *CommandRunTestStep) Size() (n int) {
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.StepDefinitionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.PatternMatches) > 0 {
		for _, e := range m.PatternMatches {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.PickleStepArgument != nil {
		l = m.PickleStepArgument.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *PatternMatch) Size() (n int) {
	var l int
	_ = l
	if len(m.Captures) > 0 {
		for _, s := range m.Captures {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.ParameterTypeName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *CommandGenerateSnippet) Size() (n int) {
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.GeneratedExpressions) > 0 {
		for _, e := range m.GeneratedExpressions {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.PickleStepArgument != nil {
		l = m.PickleStepArgument.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GeneratedExpression) Size() (n int) {
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.ParameterTypeNames) > 0 {
		for _, s := range m.ParameterTypeNames {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func sovMessages(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMessages(x uint64) (n int) {
	return sovMessages(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Envelope) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Envelope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Envelope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Source{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_Source{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GherkinDocument", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_GherkinDocument{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pickle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Pickle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_Pickle{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Attachment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_Attachment{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseStarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestCaseStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestCaseStarted{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStepStarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestStepStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestStepStarted{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStepFinished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestStepFinished{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestStepFinished{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseFinished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestCaseFinished{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestCaseFinished{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestHookStarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestHookStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestHookStarted{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestHookFinished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestHookFinished{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestHookFinished{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleAccepted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleAccepted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_PickleAccepted{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleRejected", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleRejected{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_PickleRejected{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCasePrepared", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestCasePrepared{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestCasePrepared{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestRunStarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestRunStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestRunStarted{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestRunFinished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestRunFinished{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestRunFinished{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandStart{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_CommandStart{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandActionComplete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandActionComplete{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_CommandActionComplete{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandRunBeforeTestRunHooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRunBeforeTestRunHooks{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_CommandRunBeforeTestRunHooks{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandInitializeTestCase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandInitializeTestCase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_CommandInitializeTestCase{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandRunBeforeTestCaseHook", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRunBeforeTestCaseHook{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_CommandRunBeforeTestCaseHook{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandRunTestStep", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRunTestStep{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_CommandRunTestStep{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandRunAfterTestCaseHook", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRunAfterTestCaseHook{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_CommandRunAfterTestCaseHook{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandRunAfterTestRunHooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRunAfterTestRunHooks{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_CommandRunAfterTestRunHooks{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandGenerateSnippet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandGenerateSnippet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_CommandGenerateSnippet{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = &Envelope_CommandError{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line", wireType)
			}
			m.Line = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Line |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			m.Column = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Column |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Media) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Media: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Media: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			m.Encoding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encoding |= (Media_Encoding(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Source) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Media == nil {
				m.Media = &Media{}
			}
			if err := m.Media.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GherkinDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GherkinDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Feature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Feature == nil {
				m.Feature = &GherkinDocument_Feature{}
			}
			if err := m.Feature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comments = append(m.Comments, &GherkinDocument_Comment{})
			if err := m.Comments[len(m.Comments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Comment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Comment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Comment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Feature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Feature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &GherkinDocument_Feature_Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &GherkinDocument_Feature_FeatureChild{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Tag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_FeatureChild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureChild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureChild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_FeatureChild_Rule{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &GherkinDocument_Feature_FeatureChild_Rule_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Background", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_Background{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &GherkinDocument_Feature_FeatureChild_Background{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scenario", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_Scenario{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &GherkinDocument_Feature_FeatureChild_Scenario{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &GherkinDocument_Feature_FeatureChild_RuleChild{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleChild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleChild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Background", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_Background{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &GherkinDocument_Feature_FeatureChild_RuleChild_Background{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scenario", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_Scenario{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &GherkinDocument_Feature_FeatureChild_RuleChild_Scenario{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Background) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Background: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Background: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &GherkinDocument_Feature_Step{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Scenario) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Scenario: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Scenario: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &GherkinDocument_Feature_Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &GherkinDocument_Feature_Step{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Examples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Examples = append(m.Examples, &GherkinDocument_Feature_Scenario_Examples{})
			if err := m.Examples[len(m.Examples)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Scenario_Examples) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Examples: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Examples: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &GherkinDocument_Feature_Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableHeader == nil {
				m.TableHeader = &GherkinDocument_Feature_TableRow{}
			}
			if err := m.TableHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableBody", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableBody = append(m.TableBody, &GherkinDocument_Feature_TableRow{})
			if err := m.TableBody[len(m.TableBody)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_TableRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cells = append(m.Cells, &GherkinDocument_Feature_TableRow_TableCell{})
			if err := m.Cells[len(m.Cells)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_TableRow_TableCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Step) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Step: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Step: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_Step_DocString{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Argument = &GherkinDocument_Feature_Step_DocString_{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_Step_DataTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Argument = &GherkinDocument_Feature_Step_DataTable_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Step_DataTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, &GherkinDocument_Feature_TableRow{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Step_DocString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delimiter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delimiter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Attachment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &SourceReference{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Media == nil {
				m.Media = &Media{}
			}
			if err := m.Media.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pickle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pickle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pickle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &Pickle_PickleStep{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Pickle_PickleTag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locations = append(m.Locations, &Location{})
			if err := m.Locations[len(m.Locations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pickle_PickleTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pickle_PickleStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locations = append(m.Locations, &Location{})
			if err := m.Locations[len(m.Locations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Argument", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Argument == nil {
				m.Argument = &PickleStepArgument{}
			}
			if err := m.Argument.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleStepArgument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleStepArgument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleStepArgument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleStepArgument_PickleDocString{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &PickleStepArgument_DocString{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleStepArgument_PickleTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &PickleStepArgument_DataTable{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleStepArgument_PickleDocString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleDocString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleDocString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleStepArgument_PickleTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, &PickleStepArgument_PickleTable_PickleTableRow{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleStepArgument_PickleTable_PickleTableRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleTableRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleTableRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cells = append(m.Cells, &PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell{})
			if err := m.Cells[len(m.Cells)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleTableCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleTableCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleAccepted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleAccepted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleAccepted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleRejected) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleRejected: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleRejected: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestRunStarted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestRunStarted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestRunStarted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &google_protobuf.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCasePreparedStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCasePreparedStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCasePreparedStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceLocation == nil {
				m.SourceLocation = &SourceReference{}
			}
			if err := m.SourceLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionLocation == nil {
				m.ActionLocation = &SourceReference{}
			}
			if err := m.ActionLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCasePrepared) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCasePrepared: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCasePrepared: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &TestCasePreparedStep{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCaseStarted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCaseStarted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCaseStarted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &google_protobuf.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Platform == nil {
				m.Platform = &TestCaseStarted_Platform{}
			}
			if err := m.Platform.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCaseStarted_Platform) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Platform: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Platform: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Implementation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Implementation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Os = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpu = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCaseFinished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCaseFinished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCaseFinished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &google_protobuf.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TestResult == nil {
				m.TestResult = &TestResult{}
			}
			if err := m.TestResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestStepStarted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestStepStarted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestStepStarted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &google_protobuf.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestStepFinished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestStepFinished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestStepFinished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TestResult == nil {
				m.TestResult = &TestResult{}
			}
			if err := m.TestResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &google_protobuf.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestHookStarted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestHookStarted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestHookStarted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &google_protobuf.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestHookFinished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestHookFinished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestHookFinished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TestResult == nil {
				m.TestResult = &TestResult{}
			}
			if err := m.TestResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &google_protobuf.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (TestResult_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationNanoseconds", wireType)
			}
			m.DurationNanoseconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationNanoseconds |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestRunFinished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestRunFinished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestRunFinished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDirectory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDirectory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcesConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourcesConfig == nil {
				m.SourcesConfig = &SourcesConfig{}
			}
			if err := m.SourcesConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuntimeConfig == nil {
				m.RuntimeConfig = &RuntimeConfig{}
			}
			if err := m.RuntimeConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportCodeConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SupportCodeConfig == nil {
				m.SupportCodeConfig = &SupportCodeConfig{}
			}
			if err := m.SupportCodeConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourcesConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourcesConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourcesConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbsolutePaths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbsolutePaths = append(m.AbsolutePaths, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filters == nil {
				m.Filters = &SourcesFilterConfig{}
			}
			if err := m.Filters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &SourcesOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourcesFilterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourcesFilterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourcesFilterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameRegularExpressions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameRegularExpressions = append(m.NameRegularExpressions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UriToLinesMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UriToLinesMapping = append(m.UriToLinesMapping, &UriToLinesMapping{})
			if err := m.UriToLinesMapping[len(m.UriToLinesMapping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UriToLinesMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UriToLinesMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UriToLinesMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbsolutePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbsolutePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Lines = append(m.Lines, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Lines = append(m.Lines, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Lines", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourcesOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourcesOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourcesOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (SourcesOrderType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			m.Seed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seed |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuntimeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuntimeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuntimeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFailFast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFailFast = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDryRun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDryRun = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStrict", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStrict = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxParallel", wireType)
			}
			m.MaxParallel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxParallel |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupportCodeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupportCodeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupportCodeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeforeTestCaseHookDefinitionConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BeforeTestCaseHookDefinitionConfigs = append(m.BeforeTestCaseHookDefinitionConfigs, &TestCaseHookDefinitionConfig{})
			if err := m.BeforeTestCaseHookDefinitionConfigs[len(m.BeforeTestCaseHookDefinitionConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterTestCaseHookDefinitionConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AfterTestCaseHookDefinitionConfigs = append(m.AfterTestCaseHookDefinitionConfigs, &TestCaseHookDefinitionConfig{})
			if err := m.AfterTestCaseHookDefinitionConfigs[len(m.AfterTestCaseHookDefinitionConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepDefinitionConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepDefinitionConfigs = append(m.StepDefinitionConfigs, &StepDefinitionConfig{})
			if err := m.StepDefinitionConfigs[len(m.StepDefinitionConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterTypeConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParameterTypeConfigs = append(m.ParameterTypeConfigs, &ParameterTypeConfig{})
			if err := m.ParameterTypeConfigs[len(m.ParameterTypeConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCaseHookDefinitionConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCaseHookDefinitionConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCaseHookDefinitionConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &SourceReference{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepDefinitionConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepDefinitionConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepDefinitionConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &StepDefinitionPattern{}
			}
			if err := m.Pattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &SourceReference{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepDefinitionPattern) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepDefinitionPattern: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepDefinitionPattern: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (StepDefinitionPatternType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParameterTypeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParameterTypeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParameterTypeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegularExpressions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegularExpressions = append(m.RegularExpressions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreferForRegularExpressionMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreferForRegularExpressionMatch = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseForSnippets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseForSnippets = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandActionComplete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandActionComplete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandActionComplete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompletedId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestResult{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &CommandActionComplete_TestResult{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snippet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = &CommandActionComplete_Snippet{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRunBeforeTestRunHooks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRunBeforeTestRunHooks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRunBeforeTestRunHooks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRunAfterTestRunHooks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRunAfterTestRunHooks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRunAfterTestRunHooks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandInitializeTestCase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandInitializeTestCase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandInitializeTestCase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pickle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pickle == nil {
				m.Pickle = &Pickle{}
			}
			if err := m.Pickle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRunBeforeTestCaseHook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRunBeforeTestCaseHook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRunBeforeTestCaseHook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseHookDefinitionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseHookDefinitionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRunAfterTestCaseHook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRunAfterTestCaseHook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRunAfterTestCaseHook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseHookDefinitionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseHookDefinitionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRunTestStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRunTestStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRunTestStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepDefinitionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepDefinitionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatternMatches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PatternMatches = append(m.PatternMatches, &PatternMatch{})
			if err := m.PatternMatches[len(m.PatternMatches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleStepArgument", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PickleStepArgument == nil {
				m.PickleStepArgument = &PickleStepArgument{}
			}
			if err := m.PickleStepArgument.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatternMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatternMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatternMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Captures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Captures = append(m.Captures, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterTypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParameterTypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandGenerateSnippet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandGenerateSnippet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandGenerateSnippet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedExpressions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeneratedExpressions = append(m.GeneratedExpressions, &GeneratedExpression{})
			if err := m.GeneratedExpressions[len(m.GeneratedExpressions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleStepArgument", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PickleStepArgument == nil {
				m.PickleStepArgument = &PickleStepArgument{}
			}
			if err := m.PickleStepArgument.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeneratedExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeneratedExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeneratedExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterTypeNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParameterTypeNames = append(m.ParameterTypeNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessages(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMessages
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMessages(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMessages = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessages   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("messages.proto", fileDescriptorMessages) }

var fileDescriptorMessages = []byte{
	// 3127 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x5a, 0xcf, 0x6f, 0x1b, 0xc7,
	0xf5, 0xe7, 0x92, 0x4b, 0x8a, 0x7c, 0x96, 0x64, 0x6a, 0x2c, 0x2b, 0x34, 0x63, 0x38, 0xfa, 0x6e,
	0x12, 0xc7, 0x5f, 0x27, 0xa5, 0x1b, 0x37, 0x70, 0x5d, 0x23, 0x41, 0x2c, 0x91, 0x94, 0x28, 0x55,
	0x92, 0xd5, 0xa1, 0x94, 0xc6, 0x09, 0x5c, 0x65, 0xb5, 0x1c, 0x51, 0x5b, 0x2f, 0x77, 0x17, 0xfb,
	0x23, 0xb1, 0x0a, 0x14, 0x28, 0x8a, 0x5e, 0x72, 0x69, 0x8b, 0x16, 0x6d, 0x7a, 0xe8, 0xa5, 0x4d,
	0x2f, 0xed, 0x29, 0x87, 0xfe, 0x01, 0x3d, 0x15, 0xfd, 0x71, 0xc9, 0x9f, 0x60, 0xb8, 0xb7, 0x5e,
	0xdb, 0x1e, 0x7a, 0x28, 0x50, 0xcc, 0xec, 0xcc, 0xfe, 0x20, 0x97, 0x2b, 0x51, 0xb2, 0x81, 0xa0,
	0x27, 0x72, 0xde, 0xbc, 0xf7, 0x99, 0xf7, 0x63, 0xf6, 0xcd, 0xbc, 0x99, 0x81, 0xd9, 0x01, 0x71,
	0x5d, 0xb5, 0x4f, 0xdc, 0x86, 0xed, 0x58, 0x9e, 0x85, 0xe6, 0x75, 0xab, 0xa1, 0xf9, 0x9a, 0x3f,
	0xd8, 0x27, 0x4e, 0x43, 0xf4, 0xd5, 0x5f, 0xe8, 0x5b, 0x56, 0xdf, 0x20, 0x37, 0x18, 0xcf, 0xbe,
	0x7f, 0x70, 0xc3, 0xd3, 0x07, 0xc4, 0xf5, 0xd4, 0x81, 0x1d, 0x88, 0x29, 0xbf, 0x9c, 0x83, 0x72,
	0xdb, 0xfc, 0x90, 0x18, 0x96, 0x4d, 0xd0, 0x2d, 0x28, 0xb9, 0x96, 0xef, 0x68, 0xa4, 0x26, 0x2d,
	0x4a, 0xd7, 0xce, 0xdd, 0xbc, 0xdc, 0x48, 0x03, 0x6d, 0x74, 0x19, 0x4f, 0x27, 0x87, 0x39, 0x37,
	0xfa, 0x06, 0x9c, 0xef, 0x1f, 0x12, 0xe7, 0xa1, 0x6e, 0xb6, 0x2c, 0xcd, 0x1f, 0x10, 0xd3, 0xab,
	0xe5, 0x19, 0xc0, 0xcb, 0xe9, 0x00, 0xab, 0x49, 0xe6, 0x4e, 0x0e, 0x0f, 0xcb, 0x53, 0x55, 0x6c,
	0x5d, 0x7b, 0x68, 0x90, 0x5a, 0x21, 0x4b, 0x95, 0x6d, 0xc6, 0x43, 0x55, 0x09, 0xb8, 0xd1, 0x32,
	0x80, 0xea, 0x79, 0xaa, 0x76, 0xc8, 0xb4, 0x90, 0x99, 0xec, 0x62, 0xba, 0xec, 0x52, 0xc8, 0xd7,
	0xc9, 0xe1, 0x98, 0x14, 0x35, 0xc7, 0x23, 0xae, 0xd7, 0x54, 0x5d, 0xd2, 0xf5, 0x54, 0xc7, 0x23,
	0xbd, 0x5a, 0x31, 0xcb, 0x9c, 0x9d, 0x24, 0x33, 0x35, 0x67, 0x48, 0x5e, 0x40, 0x76, 0x3d, 0x62,
	0x0b, 0xc8, 0xd2, 0x71, 0x90, 0x31, 0x66, 0x01, 0x19, 0x23, 0xa1, 0x1d, 0xa8, 0x0a, 0xd2, 0x8a,
	0x6e, 0xea, 0xee, 0x21, 0xe9, 0xd5, 0xa6, 0x18, 0xe6, 0xd5, 0x6c, 0x4c, 0xc1, 0xdd, 0xc9, 0xe1,
	0x11, 0x04, 0x81, 0x4a, 0x75, 0x0f, 0x51, 0xcb, 0xc7, 0xa1, 0xc6, 0xb9, 0x05, 0x6a, 0x9c, 0x26,
	0xcc, 0xef, 0x58, 0xd6, 0x43, 0x61, 0x7e, 0xe5, 0x38, 0xf3, 0x63, 0xcc, 0xc2, 0xfc, 0x18, 0x49,
	0x28, 0x4a, 0x49, 0xa1, 0xa2, 0x70, 0x9c, 0xa2, 0x71, 0x6e, 0xa1, 0x68, 0x9c, 0x86, 0xb6, 0x60,
	0x36, 0x98, 0x48, 0x4b, 0x9a, 0x46, 0x6c, 0xaa, 0xe7, 0x39, 0x86, 0xf9, 0x52, 0xd6, 0xf4, 0x13,
	0xbc, 0x9d, 0x1c, 0x1e, 0x92, 0x8e, 0xf0, 0x30, 0xf9, 0x36, 0xd1, 0x28, 0xde, 0xf4, 0xf1, 0x78,
	0x82, 0x37, 0xc2, 0x13, 0x94, 0x78, 0x78, 0xb6, 0x1d, 0x62, 0xab, 0x0e, 0xe9, 0xd5, 0x66, 0x4e,
	0x12, 0x1e, 0xc1, 0x1d, 0x0f, 0x8f, 0xa0, 0x51, 0x2d, 0x29, 0x0d, 0xfb, 0xa6, 0x88, 0xce, 0x6c,
	0x96, 0x96, 0x3b, 0x09, 0x5e, 0xaa, 0x65, 0x52, 0x5a, 0x84, 0x1b, 0xfb, 0x66, 0x18, 0x9a, 0xf3,
	0xc7, 0x85, 0x3b, 0xc6, 0x2c, 0xc2, 0x1d, 0x23, 0xa1, 0x0e, 0x4c, 0x6b, 0xd6, 0x60, 0xa0, 0x9a,
	0x3d, 0x36, 0x48, 0xad, 0xca, 0xf0, 0x94, 0x74, 0xbc, 0x66, 0x8c, 0xb3, 0x93, 0xc3, 0x09, 0x49,
	0xa4, 0xc1, 0x45, 0xde, 0x5e, 0xd2, 0x3c, 0xdd, 0x32, 0x9b, 0xd6, 0xc0, 0x36, 0x88, 0x47, 0x6a,
	0x73, 0x0c, 0xf2, 0xd5, 0x4c, 0xc8, 0xa4, 0x48, 0x27, 0x87, 0xd3, 0xb1, 0xd0, 0x23, 0xb8, 0xcc,
	0x3b, 0xb0, 0x6f, 0x2e, 0x93, 0x03, 0xcb, 0x21, 0xdc, 0x48, 0x3a, 0xdd, 0xdc, 0x1a, 0x62, 0x63,
	0xdd, 0xcc, 0x1c, 0x2b, 0x55, 0xb2, 0x93, 0xc3, 0x99, 0xc8, 0xc8, 0x82, 0x4b, 0xbc, 0x7f, 0xcd,
	0xd4, 0x3d, 0x5d, 0x35, 0xf4, 0xef, 0x10, 0x31, 0x09, 0x6a, 0x17, 0xd8, 0xb0, 0x37, 0x32, 0x87,
	0x1d, 0x15, 0xeb, 0xe4, 0xf0, 0x78, 0xcc, 0x71, 0xa6, 0x32, 0x41, 0xcb, 0x7a, 0x58, 0x9b, 0x9f,
	0xd4, 0x54, 0x21, 0x39, 0xce, 0x54, 0xd1, 0x8f, 0xde, 0x03, 0x14, 0xf5, 0x8b, 0xec, 0x56, 0xbb,
	0xc8, 0xc6, 0xbb, 0x76, 0xdc, 0x78, 0x82, 0xbf, 0x93, 0xc3, 0x29, 0x28, 0xc8, 0x87, 0xe7, 0x23,
	0xea, 0xd2, 0x81, 0x47, 0x9c, 0x84, 0x51, 0x0b, 0x6c, 0x90, 0xd7, 0x8f, 0x1b, 0x64, 0x44, 0xb0,
	0x93, 0xc3, 0x59, 0xb8, 0x63, 0x86, 0x0d, 0xa7, 0xcd, 0x73, 0x13, 0x0e, 0x1b, 0x9b, 0x35, 0x59,
	0xb8, 0xe8, 0x00, 0x16, 0x78, 0xf7, 0x2a, 0x31, 0x89, 0xa3, 0x7a, 0xa4, 0x6b, 0xea, 0xb6, 0x4d,
	0xbc, 0x5a, 0x8d, 0x8d, 0xf8, 0x5a, 0xe6, 0x88, 0x43, 0x32, 0x9d, 0x1c, 0x1e, 0x83, 0x86, 0x5e,
	0x0a, 0xbf, 0xe2, 0xb6, 0xe3, 0x58, 0x4e, 0xed, 0xd2, 0xa2, 0x74, 0xad, 0x12, 0xfb, 0x42, 0x19,
	0x75, 0xb9, 0x02, 0x53, 0x7c, 0x08, 0xe5, 0x16, 0x94, 0x37, 0x2c, 0x4d, 0xa5, 0xdf, 0x16, 0x42,
	0x20, 0x1b, 0xba, 0x19, 0xec, 0x4d, 0x66, 0x30, 0xfb, 0x8f, 0x16, 0xa0, 0xa4, 0x59, 0x86, 0x3f,
	0x30, 0xd9, 0x86, 0x63, 0x06, 0xf3, 0x96, 0xb2, 0x07, 0xe7, 0x83, 0x5d, 0x0a, 0x26, 0x07, 0xc4,
	0x21, 0xa6, 0x46, 0x50, 0x15, 0x0a, 0xbe, 0xa3, 0x33, 0xe9, 0x0a, 0xa6, 0x7f, 0xd1, 0x1d, 0x28,
	0x1b, 0x1c, 0x9c, 0xef, 0x57, 0xae, 0xa4, 0xdb, 0x29, 0x54, 0xc0, 0x21, 0xbf, 0xf2, 0x43, 0x09,
	0x8a, 0x9b, 0xa4, 0xa7, 0xab, 0xe8, 0x2e, 0x94, 0x89, 0xa9, 0x59, 0x3d, 0xdd, 0xec, 0x33, 0xf0,
	0xd9, 0x71, 0x69, 0x93, 0xb1, 0x37, 0xda, 0x9c, 0x17, 0x87, 0x52, 0xe8, 0xff, 0xa8, 0x57, 0x4c,
	0x8f, 0x98, 0xde, 0x9e, 0x77, 0x64, 0x13, 0xa6, 0x4b, 0x05, 0x9f, 0xe3, 0xb4, 0x9d, 0x23, 0x9b,
	0x28, 0x8b, 0x74, 0x97, 0xc6, 0xd9, 0x01, 0x4a, 0xcb, 0x4b, 0xdd, 0xf6, 0xad, 0x37, 0xaa, 0x39,
	0x54, 0x06, 0x79, 0x77, 0x67, 0xe5, 0x76, 0x55, 0x52, 0x54, 0x28, 0x05, 0x16, 0xa7, 0x18, 0x8a,
	0x40, 0xee, 0xa9, 0x9e, 0xca, 0x81, 0xd9, 0x7f, 0xf4, 0x3a, 0x14, 0x07, 0x54, 0x21, 0xbe, 0xbf,
	0x7a, 0x3e, 0x43, 0x67, 0x1c, 0x70, 0x2a, 0x3f, 0xab, 0xc3, 0xf9, 0xa1, 0xad, 0x5b, 0xca, 0x60,
	0xab, 0x30, 0x75, 0x40, 0x54, 0xcf, 0x77, 0x08, 0x77, 0xea, 0x97, 0x4e, 0xb4, 0x09, 0x6c, 0xac,
	0x04, 0x42, 0x58, 0x48, 0xa3, 0x35, 0x28, 0xd3, 0x69, 0x41, 0x4c, 0xcf, 0xad, 0x15, 0x16, 0x0b,
	0x27, 0x47, 0x6a, 0x06, 0x52, 0x38, 0x14, 0xaf, 0xdf, 0x87, 0x29, 0x4e, 0x4c, 0x04, 0x5d, 0x9a,
	0x2c, 0xe8, 0xd4, 0x8f, 0x1e, 0x79, 0xe4, 0x09, 0x3f, 0xd2, 0xff, 0xf5, 0xef, 0xd5, 0x60, 0x8a,
	0xab, 0x7e, 0x26, 0xec, 0x36, 0xc8, 0x9e, 0xda, 0x77, 0x6b, 0x79, 0x66, 0xe9, 0xeb, 0x13, 0xf9,
	0xac, 0xb1, 0xa3, 0xf6, 0x31, 0x13, 0x47, 0x75, 0x28, 0x1b, 0xaa, 0xd9, 0xf7, 0xd5, 0x7e, 0xb0,
	0x73, 0xae, 0xe0, 0xb0, 0x8d, 0x6a, 0x30, 0xf5, 0x90, 0x1c, 0x7d, 0x64, 0x39, 0x3d, 0xb6, 0x31,
	0xae, 0x60, 0xd1, 0xa4, 0x86, 0x99, 0xea, 0x80, 0xb0, 0x6d, 0x6e, 0x05, 0xb3, 0xff, 0x68, 0x11,
	0xce, 0xf5, 0x88, 0xab, 0x39, 0xba, 0xcd, 0xec, 0x29, 0x05, 0x93, 0x32, 0x46, 0x42, 0xef, 0x40,
	0x59, 0x3b, 0xd4, 0x8d, 0x9e, 0x43, 0xcc, 0xda, 0x14, 0x53, 0xfb, 0xce, 0x64, 0x6a, 0xf3, 0xdf,
	0x26, 0x05, 0xc1, 0x21, 0x56, 0x7d, 0x17, 0x0a, 0x3b, 0x6a, 0xff, 0xac, 0x91, 0x62, 0x06, 0xe5,
	0x23, 0x83, 0xea, 0x8f, 0x8b, 0x30, 0x1d, 0x1f, 0x11, 0xed, 0x82, 0xec, 0xf8, 0x86, 0x28, 0x76,
	0xde, 0x3e, 0xbd, 0xee, 0x0d, 0xec, 0xb3, 0x22, 0x84, 0xc1, 0xa1, 0xf7, 0x00, 0xf6, 0x55, 0xed,
	0x61, 0xdf, 0xb1, 0x7c, 0xb3, 0xc7, 0xbf, 0x81, 0xdb, 0x93, 0x81, 0x2f, 0x87, 0xf2, 0xb4, 0x34,
	0x89, 0xd0, 0xd0, 0x0e, 0x94, 0x5d, 0x8d, 0x98, 0xaa, 0xa3, 0x5b, 0xfc, 0xc3, 0xbd, 0x35, 0x19,
	0x72, 0x97, 0x4b, 0x77, 0x72, 0x38, 0x44, 0xaa, 0xff, 0x53, 0x02, 0x99, 0x9a, 0x70, 0x26, 0x97,
	0xc7, 0x66, 0x57, 0x3e, 0x7d, 0x76, 0x15, 0xc6, 0xcf, 0x2e, 0x79, 0x74, 0x76, 0x7d, 0x10, 0x9b,
	0x5d, 0x45, 0x36, 0xbb, 0x5a, 0x67, 0x8c, 0xd0, 0xf0, 0x3c, 0xfb, 0xa3, 0x04, 0x95, 0x90, 0x3e,
	0x14, 0x36, 0xe9, 0x99, 0x85, 0x2d, 0xff, 0xb4, 0xc2, 0xb6, 0x3c, 0x05, 0xc5, 0x0f, 0x55, 0xc3,
	0x27, 0xe1, 0x9f, 0xfa, 0x13, 0x09, 0x20, 0x52, 0xe2, 0x0b, 0x15, 0xce, 0x0e, 0x14, 0x5d, 0x8f,
	0xd8, 0x2e, 0x8f, 0xe5, 0xcd, 0x09, 0xed, 0xf7, 0x88, 0x8d, 0x03, 0x80, 0xfa, 0xcf, 0x4b, 0x50,
	0x16, 0xfe, 0xf8, 0x22, 0xa4, 0xdc, 0x98, 0xa7, 0x0a, 0xe9, 0x9e, 0x92, 0xc7, 0x7b, 0xaa, 0x98,
	0xe1, 0xa9, 0xd2, 0x19, 0x3d, 0x85, 0xde, 0x87, 0x32, 0x79, 0xa4, 0xd2, 0x92, 0xc4, 0xe5, 0x09,
	0xfa, 0xed, 0xd3, 0x4d, 0xbb, 0x46, 0x9b, 0xc3, 0xe0, 0x10, 0xb0, 0xfe, 0xa3, 0x02, 0x94, 0x05,
	0xf9, 0x7f, 0x31, 0x0c, 0xf7, 0x61, 0xda, 0x53, 0xf7, 0x0d, 0xb2, 0x77, 0x48, 0xd4, 0x1e, 0x71,
	0xf8, 0x79, 0xcd, 0xad, 0x49, 0xd5, 0xdb, 0x37, 0x08, 0xb6, 0x3e, 0xc2, 0xe7, 0x18, 0x56, 0x87,
	0x41, 0xa1, 0x5d, 0x80, 0x00, 0x7a, 0xdf, 0xea, 0x1d, 0xf1, 0xc8, 0x9c, 0x16, 0xb8, 0xc2, 0x90,
	0x96, 0xad, 0xde, 0x51, 0xfd, 0x3f, 0x12, 0x94, 0x05, 0xfd, 0x4c, 0x11, 0x79, 0x07, 0x8a, 0x1a,
	0x31, 0x0c, 0x11, 0x92, 0xbb, 0xa7, 0x53, 0x2d, 0xf8, 0xd3, 0x24, 0x86, 0x81, 0x03, 0xb8, 0xfa,
	0x03, 0xa8, 0x84, 0xb4, 0x33, 0x29, 0x38, 0xcf, 0x13, 0x1e, 0x4f, 0x4d, 0x3c, 0xfb, 0xfd, 0x4b,
	0x06, 0x99, 0x15, 0x6f, 0xcf, 0x2c, 0xef, 0xb1, 0xdd, 0x5f, 0x21, 0xda, 0xfd, 0xa1, 0x07, 0x00,
	0x3d, 0x4b, 0xdb, 0x73, 0x3d, 0x87, 0x6e, 0xff, 0x83, 0x53, 0xc2, 0x37, 0x27, 0xff, 0x60, 0x1b,
	0x2d, 0x4b, 0xeb, 0x32, 0x8c, 0x4e, 0x0e, 0x57, 0x7a, 0xa2, 0xc1, 0xe0, 0x55, 0x4f, 0xdd, 0x63,
	0x31, 0xe6, 0x33, 0xf0, 0x54, 0xf0, 0xaa, 0xa7, 0x32, 0xcf, 0x33, 0x78, 0xd1, 0xa8, 0xff, 0x54,
	0x82, 0x4a, 0xd8, 0x75, 0x26, 0xaf, 0xad, 0x83, 0xec, 0x58, 0x1f, 0x89, 0x09, 0x73, 0xda, 0xb9,
	0xcc, 0x30, 0xea, 0xbf, 0xa6, 0x5a, 0x85, 0x2e, 0x38, 0x8b, 0x56, 0xc7, 0x17, 0x56, 0x34, 0xdc,
	0xbc, 0x29, 0xb2, 0x06, 0x6f, 0xa2, 0xcb, 0x50, 0xe9, 0x11, 0x43, 0x1f, 0xe8, 0x1e, 0x71, 0x78,
	0xea, 0x88, 0x08, 0xcb, 0x00, 0x65, 0xd5, 0xe9, 0x33, 0x3b, 0x94, 0x9f, 0x48, 0x00, 0xd1, 0x61,
	0x32, 0x7a, 0x6b, 0xe8, 0x14, 0xfd, 0xe5, 0xac, 0x53, 0xf4, 0xb0, 0x3e, 0x0d, 0x0f, 0xd3, 0x9f,
	0x52, 0xb1, 0xf6, 0xa9, 0x0c, 0xa5, 0xe0, 0x38, 0x11, 0xcd, 0x42, 0x5e, 0xef, 0xf1, 0x12, 0x2d,
	0xaf, 0xf7, 0x44, 0xcd, 0x96, 0x4f, 0x14, 0x88, 0x23, 0x4b, 0x7a, 0xbc, 0x92, 0x90, 0x87, 0x2a,
	0x89, 0xb7, 0x92, 0x8b, 0xf9, 0x2b, 0x59, 0xa7, 0x99, 0xfc, 0x27, 0xbe, 0x2e, 0xdd, 0xe1, 0x19,
	0x3f, 0x58, 0xe0, 0xae, 0x9e, 0x40, 0x3a, 0x4a, 0xf3, 0x6f, 0x42, 0x45, 0xc4, 0x57, 0x2c, 0x6a,
	0xc7, 0x4d, 0x88, 0x48, 0xa0, 0xfe, 0x3e, 0x54, 0x42, 0xc0, 0xa7, 0x5e, 0x60, 0x7c, 0x26, 0x01,
	0x44, 0xc6, 0x86, 0xf9, 0x42, 0x8a, 0xe5, 0x8b, 0x84, 0xf6, 0xf9, 0x09, 0xb5, 0x47, 0xad, 0x68,
	0xd2, 0xf1, 0x5c, 0x73, 0x2d, 0xcb, 0x77, 0x54, 0x8b, 0x25, 0xce, 0x8f, 0x43, 0xc9, 0x75, 0xb9,
	0x5c, 0xa8, 0xca, 0xeb, 0x72, 0x59, 0xae, 0x16, 0x95, 0xdf, 0x16, 0x01, 0x8d, 0x32, 0xa3, 0xfb,
	0x89, 0xb4, 0x96, 0xb9, 0x17, 0x1e, 0x95, 0xe6, 0xa4, 0x31, 0x29, 0x6d, 0x37, 0x91, 0xd2, 0x82,
	0xcd, 0xf0, 0x1b, 0x13, 0x42, 0xa7, 0xa4, 0xb2, 0x8f, 0x25, 0x38, 0x3f, 0x34, 0xee, 0x99, 0xe2,
	0xbb, 0x08, 0xf1, 0x34, 0x31, 0x51, 0xe6, 0xa8, 0xff, 0x39, 0x0f, 0xe7, 0x62, 0x8a, 0xa2, 0x6f,
	0xf2, 0xe4, 0x28, 0xb1, 0x78, 0x37, 0x4f, 0x63, 0x6c, 0xfc, 0x7f, 0x94, 0x29, 0x1f, 0x4b, 0x30,
	0x9b, 0xec, 0x40, 0xba, 0x58, 0xba, 0x83, 0xc1, 0xba, 0x4f, 0x61, 0xb0, 0x78, 0x33, 0xbe, 0x9a,
	0x6b, 0xc2, 0xe3, 0xcf, 0x70, 0x4d, 0x8f, 0x9f, 0x05, 0xbe, 0x26, 0x8c, 0x0d, 0x6f, 0x57, 0xea,
	0x50, 0x0e, 0xee, 0x47, 0xd6, 0x44, 0x7a, 0x0b, 0xdb, 0x11, 0x77, 0x78, 0x77, 0x12, 0xe7, 0xce,
	0x0f, 0x71, 0xaf, 0xc3, 0x6c, 0xf2, 0x56, 0x03, 0xdd, 0x86, 0x4a, 0x78, 0x57, 0xca, 0x6d, 0xa9,
	0x37, 0x82, 0xdb, 0xd4, 0x86, 0xb8, 0x4d, 0x6d, 0xec, 0x08, 0x0e, 0x1c, 0x31, 0x2b, 0xbf, 0x97,
	0x60, 0x7e, 0xf8, 0xda, 0x85, 0x25, 0x84, 0x4d, 0x98, 0x0d, 0x72, 0xfc, 0x46, 0xd2, 0x47, 0x27,
	0x5c, 0x20, 0x86, 0x84, 0x29, 0x9c, 0xca, 0x6e, 0x1d, 0x36, 0x92, 0x87, 0x98, 0x27, 0x85, 0x4b,
	0x0a, 0x2b, 0x36, 0x54, 0x87, 0xb5, 0xce, 0x72, 0x30, 0xba, 0x2b, 0xd6, 0x80, 0x20, 0x8d, 0x5d,
	0x3f, 0xd9, 0xfd, 0x53, 0x6c, 0x19, 0x50, 0x3e, 0xcd, 0xc3, 0xf9, 0xa1, 0xbb, 0xd3, 0xcc, 0x11,
	0x13, 0x21, 0xc9, 0x4f, 0x10, 0x12, 0xb4, 0x0e, 0x65, 0xdb, 0x50, 0xbd, 0x03, 0xcb, 0x19, 0xf0,
	0x25, 0xb4, 0x71, 0xa2, 0xab, 0xdc, 0xc6, 0x36, 0x97, 0xc2, 0xa1, 0x7c, 0xdd, 0x84, 0xb2, 0xa0,
	0xa2, 0xab, 0x30, 0xab, 0xd3, 0x02, 0x88, 0x7e, 0x41, 0x51, 0x44, 0x2b, 0x78, 0x88, 0x4a, 0x73,
	0xc5, 0x87, 0xc4, 0x71, 0x45, 0x8c, 0x2a, 0x58, 0x34, 0xe9, 0xda, 0x6c, 0xb9, 0x3c, 0x81, 0xe4,
	0x2d, 0x97, 0xae, 0xcd, 0x9a, 0xed, 0xf3, 0x05, 0x97, 0xfe, 0x55, 0x7e, 0x27, 0x45, 0x81, 0x09,
	0xaf, 0xc3, 0x9e, 0x8d, 0x9b, 0xee, 0x02, 0xb0, 0x7b, 0x37, 0xe2, 0xfa, 0x86, 0xc7, 0x1d, 0xb5,
	0x98, 0x71, 0x65, 0xc7, 0xf8, 0x70, 0x4c, 0x46, 0xf9, 0x6e, 0x10, 0xd1, 0xf8, 0x3d, 0x75, 0x96,
	0xaa, 0xf3, 0x50, 0xd4, 0xcd, 0x1e, 0x79, 0xc4, 0x4f, 0xef, 0x83, 0x46, 0xd2, 0x80, 0xc2, 0x24,
	0x9f, 0xde, 0x1f, 0xb8, 0xaf, 0x12, 0x57, 0xda, 0x93, 0x2b, 0x70, 0x66, 0x3f, 0x24, 0x4d, 0x90,
	0x27, 0x31, 0xa1, 0x1f, 0x78, 0x30, 0x7e, 0xd5, 0xfd, 0x4c, 0x82, 0x1d, 0xce, 0xab, 0xc4, 0xfd,
	0x77, 0xf6, 0x07, 0x1f, 0xf7, 0x4a, 0xfe, 0xac, 0x5e, 0x99, 0x28, 0xb0, 0xff, 0x90, 0x00, 0x22,
	0x50, 0xf4, 0x36, 0x94, 0x5c, 0x4f, 0xf5, 0x7c, 0x97, 0xdf, 0xb8, 0xbc, 0x72, 0x9c, 0x1a, 0x8d,
	0x2e, 0x63, 0xc7, 0x5c, 0x8c, 0x7e, 0x90, 0x9c, 0x4b, 0x7c, 0x90, 0xbc, 0x89, 0xbe, 0x0c, 0x17,
	0x7a, 0xbe, 0xc3, 0x3e, 0xdb, 0x2d, 0xd5, 0xb4, 0x5c, 0xa2, 0x59, 0x66, 0x2f, 0xf8, 0x42, 0x65,
	0x9c, 0xd6, 0xa5, 0xbc, 0x0b, 0xa5, 0x00, 0x1d, 0xcd, 0x40, 0x65, 0x69, 0x73, 0x79, 0x6d, 0x75,
	0xf7, 0xde, 0x6e, 0xb7, 0x9a, 0x43, 0x00, 0xa5, 0x95, 0xa5, 0xb5, 0x8d, 0x76, 0xab, 0x2a, 0xd1,
	0xff, 0xdb, 0x4b, 0xdd, 0x6e, 0xbb, 0x55, 0xcd, 0xa3, 0x73, 0x30, 0xb5, 0xdd, 0xde, 0x6a, 0xad,
	0x6d, 0xad, 0x56, 0x0b, 0xb4, 0xd1, 0xfd, 0xfa, 0xda, 0xf6, 0x76, 0xbb, 0x55, 0x95, 0x29, 0xc0,
	0xee, 0x56, 0xab, 0xbd, 0xb2, 0xb6, 0xd5, 0x6e, 0x55, 0x8b, 0xca, 0xab, 0xc1, 0x5c, 0x88, 0xdf,
	0x83, 0xd7, 0x60, 0xca, 0xf5, 0x35, 0x8d, 0xb8, 0x81, 0xe9, 0x65, 0x2c, 0x9a, 0xca, 0xaf, 0xf2,
	0x30, 0x1d, 0xbf, 0xf8, 0x46, 0x2f, 0xc1, 0xcc, 0xbe, 0xea, 0x92, 0x96, 0xee, 0x10, 0xcd, 0xb3,
	0x9c, 0x23, 0x6e, 0x69, 0x92, 0x88, 0xd6, 0x60, 0x26, 0x58, 0x57, 0xdc, 0xa6, 0x65, 0x1e, 0xe8,
	0x7d, 0x1e, 0x97, 0x17, 0xb3, 0x16, 0x11, 0xce, 0x8a, 0x93, 0x92, 0x14, 0xca, 0xf1, 0x4d, 0x1a,
	0x34, 0x0e, 0x25, 0x67, 0x41, 0xe1, 0x38, 0x2b, 0x4e, 0x4a, 0xa2, 0x5d, 0x98, 0x73, 0x7d, 0xdb,
	0xb6, 0x1c, 0xaf, 0x69, 0xf5, 0x04, 0x5c, 0xb0, 0xe5, 0x1d, 0x13, 0xeb, 0xee, 0x30, 0x3b, 0x1e,
	0x45, 0x50, 0x3e, 0x97, 0x60, 0x26, 0x61, 0x02, 0x75, 0x92, 0xba, 0xef, 0x5a, 0x86, 0xef, 0x91,
	0x6d, 0xd5, 0x3b, 0x0c, 0xf6, 0x4d, 0x15, 0x9c, 0x24, 0x26, 0x6a, 0xa1, 0xfc, 0x50, 0x2d, 0xd4,
	0x84, 0xa9, 0x03, 0xdd, 0xf0, 0x88, 0xe3, 0x72, 0xd7, 0xfd, 0x7f, 0xa6, 0xeb, 0x56, 0x18, 0x2f,
	0x57, 0x51, 0x48, 0xa2, 0xdb, 0x50, 0xb4, 0x9c, 0x1e, 0x2f, 0x34, 0xc7, 0xbe, 0x6b, 0xe0, 0x10,
	0xf7, 0x28, 0x27, 0x0e, 0x04, 0x94, 0xbf, 0x48, 0x70, 0x21, 0x05, 0x9a, 0x1a, 0xe6, 0xa9, 0xfd,
	0xf6, 0x23, 0xdb, 0x21, 0xae, 0x1b, 0xad, 0x4c, 0x49, 0x22, 0xba, 0x05, 0x0b, 0xb4, 0x74, 0xc1,
	0xa4, 0xef, 0x1b, 0xaa, 0x13, 0x75, 0x04, 0xab, 0x7a, 0x05, 0x8f, 0xe9, 0xa5, 0xf1, 0xf1, 0x1d,
	0x7d, 0xc7, 0xda, 0xd0, 0x4d, 0xe2, 0x6e, 0xaa, 0xb6, 0x4d, 0xeb, 0x84, 0x42, 0x56, 0x31, 0xb8,
	0x3b, 0xcc, 0x8e, 0x47, 0x11, 0x94, 0x4d, 0x98, 0x1b, 0xe1, 0x43, 0x0a, 0x4c, 0xc7, 0xa3, 0xc1,
	0x0d, 0x49, 0xd0, 0x68, 0x1e, 0x37, 0xa8, 0x0c, 0x53, 0x5b, 0xc6, 0x41, 0x43, 0xf9, 0x16, 0x4c,
	0xc7, 0x5d, 0xc6, 0xea, 0x4e, 0xba, 0x9b, 0x0f, 0x92, 0xc6, 0xd5, 0xe3, 0x9d, 0x4c, 0x37, 0xfa,
	0x98, 0xc9, 0xd0, 0x6a, 0xce, 0x25, 0x24, 0xd8, 0x39, 0xca, 0x98, 0xfd, 0x57, 0x3e, 0x96, 0x60,
	0x26, 0x31, 0x8d, 0xd1, 0x15, 0x00, 0xdd, 0x5d, 0x51, 0x75, 0x63, 0x45, 0x75, 0x3d, 0xfe, 0x85,
	0xc6, 0x28, 0x74, 0x22, 0xe9, 0x6e, 0xcb, 0x39, 0xc2, 0x7e, 0xb0, 0x13, 0x28, 0xe3, 0xb0, 0x1d,
	0xf4, 0xd1, 0xd2, 0x45, 0x0b, 0xd6, 0x1c, 0xd6, 0x17, 0xb4, 0x69, 0x39, 0x32, 0x50, 0x1f, 0x6d,
	0xab, 0x8e, 0x6a, 0x18, 0xc4, 0x60, 0xb3, 0x44, 0xc6, 0x71, 0x92, 0xf2, 0xb8, 0x00, 0x73, 0x23,
	0xdf, 0x00, 0xfa, 0x81, 0x04, 0x2f, 0xee, 0x8f, 0xbc, 0x9c, 0x68, 0x91, 0x03, 0xdd, 0xd4, 0x83,
	0x07, 0x2b, 0x94, 0x4d, 0x54, 0x0b, 0x37, 0xb3, 0x37, 0x45, 0x69, 0xa2, 0xf8, 0x24, 0xf0, 0xe8,
	0xfb, 0x12, 0x28, 0xea, 0xf0, 0x63, 0x87, 0x51, 0x2d, 0xf2, 0xa7, 0xd6, 0xe2, 0x04, 0xe8, 0xe8,
	0x03, 0xb8, 0x48, 0xf7, 0x9d, 0xa3, 0xc3, 0x16, 0xb2, 0x36, 0xb0, 0xdd, 0x14, 0x11, 0x9c, 0x0e,
	0x84, 0x1e, 0xc0, 0xbc, 0xad, 0x3a, 0xea, 0x80, 0x78, 0xc1, 0xd4, 0x11, 0x03, 0xc8, 0x6c, 0x80,
	0x31, 0x79, 0x61, 0x7b, 0x54, 0x02, 0xa7, 0xc2, 0x28, 0x9f, 0x48, 0x70, 0x39, 0xcb, 0xc4, 0x91,
	0x83, 0x9e, 0x91, 0x1c, 0x90, 0x4f, 0xcb, 0x01, 0x4b, 0xb1, 0xa2, 0xad, 0x30, 0x49, 0x05, 0x11,
	0xbd, 0x86, 0xf8, 0x4c, 0x82, 0xf9, 0x34, 0x47, 0x8d, 0x68, 0xd4, 0x86, 0x29, 0x5b, 0xf5, 0x3c,
	0xe2, 0x88, 0x62, 0xe5, 0xd5, 0x93, 0x78, 0x7d, 0x3b, 0x10, 0xc1, 0x42, 0xf6, 0x69, 0xa8, 0xec,
	0xc1, 0xc5, 0xd4, 0x41, 0xd0, 0x42, 0xe2, 0xf8, 0xae, 0x12, 0x9e, 0xcb, 0x35, 0x79, 0xf2, 0xc8,
	0xb3, 0xe4, 0x71, 0x63, 0x02, 0xbd, 0xa3, 0x2c, 0xa2, 0xfc, 0x55, 0x82, 0x0b, 0x29, 0x01, 0x0f,
	0x8f, 0x93, 0xa4, 0xd8, 0x01, 0x5c, 0x03, 0x90, 0x33, 0x2e, 0x2f, 0xa7, 0xf4, 0xa0, 0x0e, 0xbc,
	0x60, 0x3b, 0xd4, 0xd2, 0x15, 0xcb, 0x19, 0x49, 0xd9, 0x9b, 0xaa, 0xa7, 0x1d, 0xf2, 0xb4, 0x72,
	0x1c, 0x1b, 0x2d, 0x6b, 0x7c, 0x97, 0xac, 0x58, 0x0e, 0x7f, 0xb7, 0xe3, 0xb2, 0x84, 0x53, 0xc6,
	0x43, 0x54, 0xe5, 0x53, 0x09, 0x2e, 0xa6, 0x3e, 0x8c, 0x0b, 0x8e, 0x4f, 0x82, 0xff, 0xbd, 0x70,
	0x2b, 0x19, 0x27, 0xa1, 0xe5, 0xd3, 0xec, 0x26, 0x3b, 0xb9, 0xc4, 0x7e, 0xb2, 0x0e, 0x53, 0x2e,
	0x7f, 0xa7, 0x54, 0xe0, 0x2f, 0x89, 0x04, 0x61, 0xb9, 0x0c, 0x25, 0x27, 0xa8, 0x49, 0xee, 0xc0,
	0xe5, 0xac, 0x17, 0x75, 0x34, 0xef, 0x06, 0xa5, 0x70, 0xb4, 0xe7, 0x15, 0x6d, 0xe5, 0x6b, 0xf0,
	0x7c, 0xc6, 0xb3, 0xaa, 0x4c, 0x51, 0x17, 0x2e, 0x8d, 0x7d, 0x51, 0x97, 0x25, 0x88, 0xde, 0x98,
	0xe4, 0xe9, 0xb3, 0x78, 0xf8, 0xbc, 0x2e, 0x97, 0xf3, 0xd5, 0x82, 0xf2, 0x0b, 0x29, 0xdd, 0xd8,
	0xf0, 0x81, 0x59, 0xd6, 0xc0, 0x77, 0xa0, 0xe6, 0xa5, 0xa6, 0x97, 0x35, 0x71, 0xa5, 0x36, 0xb6,
	0x3f, 0x51, 0x38, 0xc8, 0xc9, 0xc2, 0x81, 0xab, 0xf6, 0x89, 0x94, 0xea, 0xcb, 0x2f, 0x80, 0x66,
	0xbf, 0xc9, 0x03, 0x1a, 0x7d, 0x18, 0x98, 0xa9, 0xd0, 0x75, 0xa8, 0x26, 0x97, 0x80, 0x50, 0x91,
	0x11, 0x3a, 0x5a, 0x87, 0x59, 0x9e, 0xb7, 0xd8, 0xd7, 0x45, 0xc4, 0x7a, 0xa0, 0x8c, 0x5b, 0x0f,
	0x22, 0x5e, 0x3c, 0x24, 0x99, 0x30, 0xa6, 0x38, 0x54, 0x9f, 0xbd, 0x0b, 0xc8, 0x1e, 0x39, 0xd7,
	0xe3, 0x97, 0x46, 0x27, 0x3f, 0x27, 0x4e, 0xc1, 0xe0, 0x6e, 0xea, 0xc1, 0x74, 0x5c, 0x37, 0xaa,
	0x8b, 0xa6, 0xda, 0x9e, 0xef, 0x10, 0xb1, 0x6b, 0x0e, 0xdb, 0xe8, 0x35, 0x98, 0x4b, 0x2c, 0x61,
	0x5b, 0xd1, 0x59, 0xf9, 0x68, 0x47, 0xe2, 0x44, 0xfa, 0xdf, 0x12, 0x2c, 0xa4, 0xbf, 0x2b, 0xcc,
	0x0c, 0xc8, 0x03, 0x98, 0xef, 0x73, 0xf6, 0xde, 0x70, 0xba, 0x1c, 0xbb, 0xf4, 0xae, 0x8e, 0x4a,
	0xe0, 0x54, 0x98, 0x31, 0xbe, 0x2d, 0x3e, 0x15, 0xdf, 0x46, 0xb6, 0xdf, 0x87, 0x0b, 0x29, 0x2a,
	0xa5, 0x5e, 0x24, 0x34, 0x00, 0x8d, 0xf8, 0x31, 0x5c, 0x1c, 0x46, 0x7b, 0xae, 0x7f, 0x15, 0xaa,
	0xc3, 0x1b, 0x5b, 0xf4, 0x1c, 0x5c, 0xb8, 0x87, 0x5b, 0x6d, 0xbc, 0x77, 0x6f, 0x65, 0x8f, 0x15,
	0x9d, 0x6b, 0x3b, 0x6b, 0xf7, 0xb6, 0x82, 0xc2, 0x15, 0x2f, 0x6d, 0xb5, 0xee, 0x6d, 0x56, 0xa5,
	0xeb, 0x1b, 0x70, 0x69, 0xec, 0xa2, 0x46, 0x11, 0x9a, 0xbb, 0xcd, 0xdd, 0xcd, 0xe5, 0x36, 0xde,
	0x6b, 0xbf, 0xbb, 0x8d, 0xdb, 0xdd, 0x6e, 0x80, 0xb0, 0x00, 0x08, 0xb7, 0x57, 0x77, 0x37, 0x96,
	0x12, 0x74, 0x69, 0xb9, 0xf1, 0xa7, 0x27, 0x57, 0xa4, 0xcf, 0x9f, 0x5c, 0x91, 0x1e, 0x3f, 0xb9,
	0x22, 0xfd, 0xf8, 0x6f, 0x57, 0x72, 0xef, 0x95, 0x85, 0xc3, 0xfe, 0x9e, 0x9f, 0x6b, 0x0a, 0x27,
	0x6e, 0x72, 0xda, 0x7e, 0x89, 0x1d, 0x0b, 0x7c, 0xe5, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x4c,
	0xcc, 0x5e, 0xc2, 0xee, 0x32, 0x00, 0x00,
}
